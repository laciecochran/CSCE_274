   1               		.file	"iroblib.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	defineSongs
  12               	defineSongs:
  13               	.LFB0:
  14               		.file 1 "iroblib.c"
   1:iroblib.c     **** #include "iroblib.h"
   2:iroblib.c     **** #include "oi.h"
   3:iroblib.c     **** #include "cmod.h"
   4:iroblib.c     **** 
   5:iroblib.c     **** // Define songs to be played later
   6:iroblib.c     **** void defineSongs(void) {
  15               		.loc 1 6 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
   7:iroblib.c     ****   // Reset song
   8:iroblib.c     ****   byteTx(CmdSong);
  21               		.loc 1 8 0
  22 0000 8CE8      		ldi r24,lo8(-116)
  23 0002 0E94 0000 		call byteTx
  24               	.LVL0:
   9:iroblib.c     ****   byteTx(RESET_SONG);
  25               		.loc 1 9 0
  26 0006 80E0      		ldi r24,0
  27 0008 0E94 0000 		call byteTx
  28               	.LVL1:
  10:iroblib.c     ****   byteTx(4);
  29               		.loc 1 10 0
  30 000c 84E0      		ldi r24,lo8(4)
  31 000e 0E94 0000 		call byteTx
  32               	.LVL2:
  11:iroblib.c     ****   byteTx(60);
  33               		.loc 1 11 0
  34 0012 8CE3      		ldi r24,lo8(60)
  35 0014 0E94 0000 		call byteTx
  36               	.LVL3:
  12:iroblib.c     ****   byteTx(6);
  37               		.loc 1 12 0
  38 0018 86E0      		ldi r24,lo8(6)
  39 001a 0E94 0000 		call byteTx
  40               	.LVL4:
  13:iroblib.c     ****   byteTx(72);
  41               		.loc 1 13 0
  42 001e 88E4      		ldi r24,lo8(72)
  43 0020 0E94 0000 		call byteTx
  44               	.LVL5:
  14:iroblib.c     ****   byteTx(6);
  45               		.loc 1 14 0
  46 0024 86E0      		ldi r24,lo8(6)
  47 0026 0E94 0000 		call byteTx
  48               	.LVL6:
  15:iroblib.c     ****   byteTx(84);
  49               		.loc 1 15 0
  50 002a 84E5      		ldi r24,lo8(84)
  51 002c 0E94 0000 		call byteTx
  52               	.LVL7:
  16:iroblib.c     ****   byteTx(6);
  53               		.loc 1 16 0
  54 0030 86E0      		ldi r24,lo8(6)
  55 0032 0E94 0000 		call byteTx
  56               	.LVL8:
  17:iroblib.c     ****   byteTx(96);
  57               		.loc 1 17 0
  58 0036 80E6      		ldi r24,lo8(96)
  59 0038 0E94 0000 		call byteTx
  60               	.LVL9:
  18:iroblib.c     ****   byteTx(6);
  61               		.loc 1 18 0
  62 003c 86E0      		ldi r24,lo8(6)
  63 003e 0E94 0000 		call byteTx
  64               	.LVL10:
  19:iroblib.c     **** 
  20:iroblib.c     ****   // Start song
  21:iroblib.c     ****   byteTx(CmdSong);
  65               		.loc 1 21 0
  66 0042 8CE8      		ldi r24,lo8(-116)
  67 0044 0E94 0000 		call byteTx
  68               	.LVL11:
  22:iroblib.c     ****   byteTx(START_SONG);
  69               		.loc 1 22 0
  70 0048 81E0      		ldi r24,lo8(1)
  71 004a 0E94 0000 		call byteTx
  72               	.LVL12:
  23:iroblib.c     ****   byteTx(6);
  73               		.loc 1 23 0
  74 004e 86E0      		ldi r24,lo8(6)
  75 0050 0E94 0000 		call byteTx
  76               	.LVL13:
  24:iroblib.c     ****   byteTx(69);
  77               		.loc 1 24 0
  78 0054 85E4      		ldi r24,lo8(69)
  79 0056 0E94 0000 		call byteTx
  80               	.LVL14:
  25:iroblib.c     ****   byteTx(18);
  81               		.loc 1 25 0
  82 005a 82E1      		ldi r24,lo8(18)
  83 005c 0E94 0000 		call byteTx
  84               	.LVL15:
  26:iroblib.c     ****   byteTx(72);
  85               		.loc 1 26 0
  86 0060 88E4      		ldi r24,lo8(72)
  87 0062 0E94 0000 		call byteTx
  88               	.LVL16:
  27:iroblib.c     ****   byteTx(12);
  89               		.loc 1 27 0
  90 0066 8CE0      		ldi r24,lo8(12)
  91 0068 0E94 0000 		call byteTx
  92               	.LVL17:
  28:iroblib.c     ****   byteTx(74);
  93               		.loc 1 28 0
  94 006c 8AE4      		ldi r24,lo8(74)
  95 006e 0E94 0000 		call byteTx
  96               	.LVL18:
  29:iroblib.c     ****   byteTx(12);
  97               		.loc 1 29 0
  98 0072 8CE0      		ldi r24,lo8(12)
  99 0074 0E94 0000 		call byteTx
 100               	.LVL19:
  30:iroblib.c     ****   byteTx(72);
 101               		.loc 1 30 0
 102 0078 88E4      		ldi r24,lo8(72)
 103 007a 0E94 0000 		call byteTx
 104               	.LVL20:
  31:iroblib.c     ****   byteTx(12);
 105               		.loc 1 31 0
 106 007e 8CE0      		ldi r24,lo8(12)
 107 0080 0E94 0000 		call byteTx
 108               	.LVL21:
  32:iroblib.c     ****   byteTx(69);
 109               		.loc 1 32 0
 110 0084 85E4      		ldi r24,lo8(69)
 111 0086 0E94 0000 		call byteTx
 112               	.LVL22:
  33:iroblib.c     ****   byteTx(12);
 113               		.loc 1 33 0
 114 008a 8CE0      		ldi r24,lo8(12)
 115 008c 0E94 0000 		call byteTx
 116               	.LVL23:
  34:iroblib.c     ****   byteTx(77);
 117               		.loc 1 34 0
 118 0090 8DE4      		ldi r24,lo8(77)
 119 0092 0E94 0000 		call byteTx
 120               	.LVL24:
  35:iroblib.c     ****   byteTx(24);
 121               		.loc 1 35 0
 122 0096 88E1      		ldi r24,lo8(24)
 123 0098 0C94 0000 		jmp byteTx
 124               	.LVL25:
 125               		.cfi_endproc
 126               	.LFE0:
 128               	.global	powerOnRobot
 130               	powerOnRobot:
 131               	.LFB1:
  36:iroblib.c     **** }
  37:iroblib.c     **** 
  38:iroblib.c     **** // Ensure that the robot is On.
  39:iroblib.c     **** void powerOnRobot(void) {
 132               		.loc 1 39 0
 133               		.cfi_startproc
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
  40:iroblib.c     ****   // If Create's power is off, turn it on
  41:iroblib.c     ****   if(!RobotIsOn) {
 138               		.loc 1 41 0
 139 009c 1D99      		sbic 0x3,5
 140 009e 00C0      		rjmp .L7
 141               	.L4:
 142               	.LBB2:
  42:iroblib.c     ****     while(!RobotIsOn) {
 143               		.loc 1 42 0 discriminator 1
 144 00a0 1D99      		sbic 0x3,5
 145 00a2 00C0      		rjmp .L12
 146               	.LBB3:
  43:iroblib.c     ****       RobotPwrToggleLow;
 147               		.loc 1 43 0
 148 00a4 5F98      		cbi 0xb,7
  44:iroblib.c     ****       delayMs(500);  // Delay in this state
 149               		.loc 1 44 0
 150 00a6 84EF      		ldi r24,lo8(-12)
 151 00a8 91E0      		ldi r25,lo8(1)
 152 00aa 0E94 0000 		call delayMs
 153               	.LVL26:
  45:iroblib.c     ****       RobotPwrToggleHigh;  // Low to high transition to toggle power
 154               		.loc 1 45 0
 155 00ae 5F9A      		sbi 0xb,7
  46:iroblib.c     ****       delayMs(100);  // Delay in this state
 156               		.loc 1 46 0
 157 00b0 84E6      		ldi r24,lo8(100)
 158 00b2 90E0      		ldi r25,0
 159 00b4 0E94 0000 		call delayMs
 160               	.LVL27:
  47:iroblib.c     ****       RobotPwrToggleLow;
 161               		.loc 1 47 0
 162 00b8 5F98      		cbi 0xb,7
 163 00ba 00C0      		rjmp .L4
 164               	.L12:
 165               	.LBE3:
  48:iroblib.c     ****     }
  49:iroblib.c     ****     delayMs(3500);  // Delay for startup
 166               		.loc 1 49 0
 167 00bc 8CEA      		ldi r24,lo8(-84)
 168 00be 9DE0      		ldi r25,lo8(13)
 169 00c0 0E94 0000 		call delayMs
 170               	.LVL28:
 171               	.L7:
 172               	.LBE2:
  50:iroblib.c     ****   }
  51:iroblib.c     **** 
  52:iroblib.c     ****   // Flush the buffer
  53:iroblib.c     ****   while( (UCSR0A & 0x80) && UDR0);
 173               		.loc 1 53 0 discriminator 1
 174 00c4 8091 C000 		lds r24,192
 175 00c8 87FF      		sbrs r24,7
 176 00ca 00C0      		rjmp .L2
 177               		.loc 1 53 0 is_stmt 0 discriminator 2
 178 00cc 8091 C600 		lds r24,198
 179 00d0 8111      		cpse r24,__zero_reg__
 180 00d2 00C0      		rjmp .L7
 181               	.L2:
 182 00d4 0895      		ret
 183               		.cfi_endproc
 184               	.LFE1:
 186               	.global	powerOffRobot
 188               	powerOffRobot:
 189               	.LFB2:
  54:iroblib.c     **** }
  55:iroblib.c     **** 
  56:iroblib.c     **** // Ensure that the robot is OFF.
  57:iroblib.c     **** void powerOffRobot(void) {
 190               		.loc 1 57 0 is_stmt 1
 191               		.cfi_startproc
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 0 */
 195               	.L__stack_usage = 0
  58:iroblib.c     ****   // If Create's power is on, turn it off
  59:iroblib.c     ****   if(RobotIsOn) {
 196               		.loc 1 59 0
 197 00d6 1D9B      		sbis 0x3,5
 198 00d8 0895      		ret
 199               	.L18:
  60:iroblib.c     ****     while(RobotIsOn) {
 200               		.loc 1 60 0 discriminator 1
 201 00da 1D9B      		sbis 0x3,5
 202 00dc 00C0      		rjmp .L19
 203               	.LBB4:
  61:iroblib.c     ****       RobotPwrToggleLow;
 204               		.loc 1 61 0
 205 00de 5F98      		cbi 0xb,7
  62:iroblib.c     ****       delayMs(500);  // Delay in this state
 206               		.loc 1 62 0
 207 00e0 84EF      		ldi r24,lo8(-12)
 208 00e2 91E0      		ldi r25,lo8(1)
 209 00e4 0E94 0000 		call delayMs
 210               	.LVL29:
  63:iroblib.c     ****       RobotPwrToggleHigh;  // Low to high transition to toggle power
 211               		.loc 1 63 0
 212 00e8 5F9A      		sbi 0xb,7
  64:iroblib.c     ****       delayMs(100);  // Delay in this state
 213               		.loc 1 64 0
 214 00ea 84E6      		ldi r24,lo8(100)
 215 00ec 90E0      		ldi r25,0
 216 00ee 0E94 0000 		call delayMs
 217               	.LVL30:
  65:iroblib.c     ****       RobotPwrToggleLow;
 218               		.loc 1 65 0
 219 00f2 5F98      		cbi 0xb,7
 220 00f4 00C0      		rjmp .L18
 221               	.L19:
 222 00f6 0895      		ret
 223               	.LBE4:
 224               		.cfi_endproc
 225               	.LFE2:
 227               	.global	powerLed
 229               	powerLed:
 230               	.LFB3:
  66:iroblib.c     ****     }
  67:iroblib.c     ****   }
  68:iroblib.c     **** }
  69:iroblib.c     **** 
  70:iroblib.c     **** //Turn on power Led given a specified color.
  71:iroblib.c     **** void powerLed(uint8_t color) {
 231               		.loc 1 71 0
 232               		.cfi_startproc
 233               	.LVL31:
 234 00f8 CF93      		push r28
 235               	.LCFI0:
 236               		.cfi_def_cfa_offset 3
 237               		.cfi_offset 28, -2
 238               	/* prologue: function */
 239               	/* frame size = 0 */
 240               	/* stack size = 1 */
 241               	.L__stack_usage = 1
 242 00fa C82F      		mov r28,r24
  72:iroblib.c     **** 
  73:iroblib.c     ****   byteTx(CmdLeds); 
 243               		.loc 1 73 0
 244 00fc 8BE8      		ldi r24,lo8(-117)
 245               	.LVL32:
 246 00fe 0E94 0000 		call byteTx
 247               	.LVL33:
  74:iroblib.c     ****   byteTx(0x00); //both robot Leds off
 248               		.loc 1 74 0
 249 0102 80E0      		ldi r24,0
 250 0104 0E94 0000 		call byteTx
 251               	.LVL34:
  75:iroblib.c     ****   byteTx(color);
 252               		.loc 1 75 0
 253 0108 8C2F      		mov r24,r28
 254 010a 0E94 0000 		call byteTx
 255               	.LVL35:
  76:iroblib.c     ****   byteTx(255); //intensity
 256               		.loc 1 76 0
 257 010e 8FEF      		ldi r24,lo8(-1)
 258               	/* epilogue start */
  77:iroblib.c     **** 
  78:iroblib.c     **** }
 259               		.loc 1 78 0
 260 0110 CF91      		pop r28
 261               	.LVL36:
  76:iroblib.c     ****   byteTx(255); //intensity
 262               		.loc 1 76 0
 263 0112 0C94 0000 		jmp byteTx
 264               	.LVL37:
 265               		.cfi_endproc
 266               	.LFE3:
 268               	.global	setupCMDLeds
 270               	setupCMDLeds:
 271               	.LFB4:
  79:iroblib.c     **** 
  80:iroblib.c     **** //Setup the command module Leds
  81:iroblib.c     **** void setupCMDLeds(void) {
 272               		.loc 1 81 0
 273               		.cfi_startproc
 274               	/* prologue: function */
 275               	/* frame size = 0 */
 276               	/* stack size = 0 */
 277               	.L__stack_usage = 0
  82:iroblib.c     **** 
  83:iroblib.c     ****   //Set fifth and sixth bits of direction register of port D to 1.
  84:iroblib.c     ****   //pin 5 controls right Led, pin 6 controls left Led
  85:iroblib.c     ****   DDRD |= (3 << 5);
 278               		.loc 1 85 0
 279 0116 8AB1      		in r24,0xa
 280 0118 8066      		ori r24,lo8(96)
 281 011a 8AB9      		out 0xa,r24
 282 011c 0895      		ret
 283               		.cfi_endproc
 284               	.LFE4:
 286               	.global	toggleCMDLeds
 288               	toggleCMDLeds:
 289               	.LFB5:
  86:iroblib.c     **** 
  87:iroblib.c     **** }
  88:iroblib.c     **** 
  89:iroblib.c     **** //Toggle the command module Leds
  90:iroblib.c     **** void toggleCMDLeds(void) {
 290               		.loc 1 90 0
 291               		.cfi_startproc
 292               	/* prologue: function */
 293               	/* frame size = 0 */
 294               	/* stack size = 0 */
 295               	.L__stack_usage = 0
  91:iroblib.c     ****   //turn the Leds off/on using exclusive or
  92:iroblib.c     ****   
  93:iroblib.c     ****   PORTD ^= (3 << 5);
 296               		.loc 1 93 0
 297 011e 8BB1      		in r24,0xb
 298 0120 90E6      		ldi r25,lo8(96)
 299 0122 8927      		eor r24,r25
 300 0124 8BB9      		out 0xb,r24
 301 0126 0895      		ret
 302               		.cfi_endproc
 303               	.LFE5:
 305               	.global	robotLeftLedOn
 307               	robotLeftLedOn:
 308               	.LFB7:
  94:iroblib.c     **** 
  95:iroblib.c     **** }
  96:iroblib.c     **** 
  97:iroblib.c     **** //Detect left or right bumper. Set corresponding Led
  98:iroblib.c     **** void bumperLedsNotif(void) {
  99:iroblib.c     **** 
 100:iroblib.c     ****   //Ask about bump sensors
 101:iroblib.c     ****   byteTx(CmdSensors); //"read sensors"
 102:iroblib.c     ****   byteTx(7); //sensor packet 7 for bumps and wheels
 103:iroblib.c     **** 
 104:iroblib.c     ****   //read response and extract relevant information
 105:iroblib.c     ****   uint8_t bumps = byteRx();
 106:iroblib.c     ****   uint8_t bumpRight = bumps & (1 << 0);
 107:iroblib.c     ****   uint8_t bumpLeft  = bumps & (1 << 1);
 108:iroblib.c     **** 
 109:iroblib.c     ****   //set robot Leds
 110:iroblib.c     ****   if(bumpLeft && bumpRight) {robotLedsOn();}
 111:iroblib.c     ****   else if(bumpLeft) {robotLeftLedOn();}
 112:iroblib.c     ****   else if(bumpRight) {robotRightLedOn();}
 113:iroblib.c     ****   else {robotLedsOff();}
 114:iroblib.c     **** 
 115:iroblib.c     **** }
 116:iroblib.c     **** 
 117:iroblib.c     **** //Turn on robot's left Led
 118:iroblib.c     **** void robotLeftLedOn(void) {
 309               		.loc 1 118 0
 310               		.cfi_startproc
 311               	/* prologue: function */
 312               	/* frame size = 0 */
 313               	/* stack size = 0 */
 314               	.L__stack_usage = 0
 119:iroblib.c     **** 
 120:iroblib.c     ****   byteTx(CmdLeds); 
 315               		.loc 1 120 0
 316 0128 8BE8      		ldi r24,lo8(-117)
 317 012a 0E94 0000 		call byteTx
 318               	.LVL38:
 121:iroblib.c     ****   byteTx(0x02); //
 319               		.loc 1 121 0
 320 012e 82E0      		ldi r24,lo8(2)
 321 0130 0E94 0000 		call byteTx
 322               	.LVL39:
 122:iroblib.c     ****   byteTx(0);
 323               		.loc 1 122 0
 324 0134 80E0      		ldi r24,0
 325 0136 0E94 0000 		call byteTx
 326               	.LVL40:
 123:iroblib.c     ****   byteTx(255); //intensity
 327               		.loc 1 123 0
 328 013a 8FEF      		ldi r24,lo8(-1)
 329 013c 0C94 0000 		jmp byteTx
 330               	.LVL41:
 331               		.cfi_endproc
 332               	.LFE7:
 334               	.global	robotRightLedOn
 336               	robotRightLedOn:
 337               	.LFB8:
 124:iroblib.c     **** 
 125:iroblib.c     **** }
 126:iroblib.c     **** 
 127:iroblib.c     **** //Turn on robot's right Led
 128:iroblib.c     **** void robotRightLedOn(void) {
 338               		.loc 1 128 0
 339               		.cfi_startproc
 340               	/* prologue: function */
 341               	/* frame size = 0 */
 342               	/* stack size = 0 */
 343               	.L__stack_usage = 0
 129:iroblib.c     **** 
 130:iroblib.c     ****   byteTx(CmdLeds); 
 344               		.loc 1 130 0
 345 0140 8BE8      		ldi r24,lo8(-117)
 346 0142 0E94 0000 		call byteTx
 347               	.LVL42:
 131:iroblib.c     ****   byteTx(0x08); //
 348               		.loc 1 131 0
 349 0146 88E0      		ldi r24,lo8(8)
 350 0148 0E94 0000 		call byteTx
 351               	.LVL43:
 132:iroblib.c     ****   byteTx(0);
 352               		.loc 1 132 0
 353 014c 80E0      		ldi r24,0
 354 014e 0E94 0000 		call byteTx
 355               	.LVL44:
 133:iroblib.c     ****   byteTx(255); //intensity
 356               		.loc 1 133 0
 357 0152 8FEF      		ldi r24,lo8(-1)
 358 0154 0C94 0000 		jmp byteTx
 359               	.LVL45:
 360               		.cfi_endproc
 361               	.LFE8:
 363               	.global	robotLedsOn
 365               	robotLedsOn:
 366               	.LFB9:
 134:iroblib.c     **** 
 135:iroblib.c     **** }
 136:iroblib.c     **** //Turn on both play and advance Leds
 137:iroblib.c     **** void robotLedsOn(void) {
 367               		.loc 1 137 0
 368               		.cfi_startproc
 369               	/* prologue: function */
 370               	/* frame size = 0 */
 371               	/* stack size = 0 */
 372               	.L__stack_usage = 0
 138:iroblib.c     **** 
 139:iroblib.c     ****   byteTx(CmdLeds);
 373               		.loc 1 139 0
 374 0158 8BE8      		ldi r24,lo8(-117)
 375 015a 0E94 0000 		call byteTx
 376               	.LVL46:
 140:iroblib.c     ****   byteTx(0x0a);
 377               		.loc 1 140 0
 378 015e 8AE0      		ldi r24,lo8(10)
 379 0160 0E94 0000 		call byteTx
 380               	.LVL47:
 141:iroblib.c     ****   byteTx(0);
 381               		.loc 1 141 0
 382 0164 80E0      		ldi r24,0
 383 0166 0E94 0000 		call byteTx
 384               	.LVL48:
 142:iroblib.c     ****   byteTx(255);
 385               		.loc 1 142 0
 386 016a 8FEF      		ldi r24,lo8(-1)
 387 016c 0C94 0000 		jmp byteTx
 388               	.LVL49:
 389               		.cfi_endproc
 390               	.LFE9:
 392               	.global	robotLedsOff
 394               	robotLedsOff:
 395               	.LFB10:
 143:iroblib.c     **** 
 144:iroblib.c     **** }
 145:iroblib.c     **** 
 146:iroblib.c     **** //Turn off robot's left Led
 147:iroblib.c     **** void robotLedsOff(void) {
 396               		.loc 1 147 0
 397               		.cfi_startproc
 398               	/* prologue: function */
 399               	/* frame size = 0 */
 400               	/* stack size = 0 */
 401               	.L__stack_usage = 0
 148:iroblib.c     **** 
 149:iroblib.c     ****   byteTx(CmdLeds); 
 402               		.loc 1 149 0
 403 0170 8BE8      		ldi r24,lo8(-117)
 404 0172 0E94 0000 		call byteTx
 405               	.LVL50:
 150:iroblib.c     ****   byteTx(0x00); //
 406               		.loc 1 150 0
 407 0176 80E0      		ldi r24,0
 408 0178 0E94 0000 		call byteTx
 409               	.LVL51:
 151:iroblib.c     ****   byteTx(0);
 410               		.loc 1 151 0
 411 017c 80E0      		ldi r24,0
 412 017e 0E94 0000 		call byteTx
 413               	.LVL52:
 152:iroblib.c     ****   byteTx(255);
 414               		.loc 1 152 0
 415 0182 8FEF      		ldi r24,lo8(-1)
 416 0184 0C94 0000 		jmp byteTx
 417               	.LVL53:
 418               		.cfi_endproc
 419               	.LFE10:
 421               	.global	bumperLedsNotif
 423               	bumperLedsNotif:
 424               	.LFB6:
  98:iroblib.c     **** void bumperLedsNotif(void) {
 425               		.loc 1 98 0
 426               		.cfi_startproc
 427               	/* prologue: function */
 428               	/* frame size = 0 */
 429               	/* stack size = 0 */
 430               	.L__stack_usage = 0
 101:iroblib.c     ****   byteTx(CmdSensors); //"read sensors"
 431               		.loc 1 101 0
 432 0188 8EE8      		ldi r24,lo8(-114)
 433 018a 0E94 0000 		call byteTx
 434               	.LVL54:
 102:iroblib.c     ****   byteTx(7); //sensor packet 7 for bumps and wheels
 435               		.loc 1 102 0
 436 018e 87E0      		ldi r24,lo8(7)
 437 0190 0E94 0000 		call byteTx
 438               	.LVL55:
 105:iroblib.c     ****   uint8_t bumps = byteRx();
 439               		.loc 1 105 0
 440 0194 0E94 0000 		call byteRx
 441               	.LVL56:
 106:iroblib.c     ****   uint8_t bumpRight = bumps & (1 << 0);
 442               		.loc 1 106 0
 443 0198 982F      		mov r25,r24
 444 019a 9170      		andi r25,lo8(1)
 445               	.LVL57:
 110:iroblib.c     ****   if(bumpLeft && bumpRight) {robotLedsOn();}
 446               		.loc 1 110 0
 447 019c 81FF      		sbrs r24,1
 448 019e 00C0      		rjmp .L28
 110:iroblib.c     ****   if(bumpLeft && bumpRight) {robotLedsOn();}
 449               		.loc 1 110 0 is_stmt 0 discriminator 1
 450 01a0 9111      		cpse r25,__zero_reg__
 451 01a2 0C94 0000 		jmp robotLedsOn
 452               	.LVL58:
 453               	.L29:
 111:iroblib.c     ****   else if(bumpLeft) {robotLeftLedOn();}
 454               		.loc 1 111 0 is_stmt 1 discriminator 1
 455 01a6 0C94 0000 		jmp robotLeftLedOn
 456               	.LVL59:
 457               	.L28:
 112:iroblib.c     ****   else if(bumpRight) {robotRightLedOn();}
 458               		.loc 1 112 0
 459 01aa 9111      		cpse r25,__zero_reg__
 112:iroblib.c     ****   else if(bumpRight) {robotRightLedOn();}
 460               		.loc 1 112 0 is_stmt 0 discriminator 1
 461 01ac 0C94 0000 		jmp robotRightLedOn
 462               	.LVL60:
 463               	.L30:
 113:iroblib.c     ****   else {robotLedsOff();}
 464               		.loc 1 113 0 is_stmt 1
 465 01b0 0C94 0000 		jmp robotLedsOff
 466               	.LVL61:
 467               		.cfi_endproc
 468               	.LFE6:
 470               	.global	drivePentagon
 472               	drivePentagon:
 473               	.LFB11:
 153:iroblib.c     **** }
 154:iroblib.c     **** 
 155:iroblib.c     **** //drive the create around a pentagon
 156:iroblib.c     **** void drivePentagon(void) {
 474               		.loc 1 156 0
 475               		.cfi_startproc
 476               	/* prologue: function */
 477               	/* frame size = 0 */
 478               	/* stack size = 0 */
 479               	.L__stack_usage = 0
 480 01b4 0895      		ret
 481               		.cfi_endproc
 482               	.LFE11:
 484               	.global	driveStraight
 486               	driveStraight:
 487               	.LFB12:
 157:iroblib.c     **** 
 158:iroblib.c     ****   
 159:iroblib.c     **** 
 160:iroblib.c     **** }
 161:iroblib.c     **** 
 162:iroblib.c     **** //drive create straight for a specified distance
 163:iroblib.c     **** void driveStraight(uint16_t distance) {
 488               		.loc 1 163 0
 489               		.cfi_startproc
 490               	.LVL62:
 491               	/* prologue: function */
 492               	/* frame size = 0 */
 493               	/* stack size = 0 */
 494               	.L__stack_usage = 0
 164:iroblib.c     **** 
 165:iroblib.c     ****   byteTx(CmdDriveWheels);
 495               		.loc 1 165 0
 496 01b6 81E9      		ldi r24,lo8(-111)
 497               	.LVL63:
 498 01b8 0E94 0000 		call byteTx
 499               	.LVL64:
 166:iroblib.c     ****   byteTx(0x6);
 500               		.loc 1 166 0
 501 01bc 86E0      		ldi r24,lo8(6)
 502 01be 0E94 0000 		call byteTx
 503               	.LVL65:
 167:iroblib.c     ****   byteTx(0x4);
 504               		.loc 1 167 0
 505 01c2 84E0      		ldi r24,lo8(4)
 506 01c4 0C94 0000 		jmp byteTx
 507               	.LVL66:
 508               		.cfi_endproc
 509               	.LFE12:
 511               	.Letext0:
 512               		.file 2 "/usr/lib/avr/include/stdint.h"
 513               		.file 3 "cmod.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 iroblib.c
     /tmp/ccVFpSmy.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccVFpSmy.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccVFpSmy.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccVFpSmy.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccVFpSmy.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccVFpSmy.s:12     .text:0000000000000000 defineSongs
     /tmp/ccVFpSmy.s:130    .text:000000000000009c powerOnRobot
     /tmp/ccVFpSmy.s:188    .text:00000000000000d6 powerOffRobot
     /tmp/ccVFpSmy.s:229    .text:00000000000000f8 powerLed
     /tmp/ccVFpSmy.s:270    .text:0000000000000116 setupCMDLeds
     /tmp/ccVFpSmy.s:288    .text:000000000000011e toggleCMDLeds
     /tmp/ccVFpSmy.s:307    .text:0000000000000128 robotLeftLedOn
     /tmp/ccVFpSmy.s:336    .text:0000000000000140 robotRightLedOn
     /tmp/ccVFpSmy.s:365    .text:0000000000000158 robotLedsOn
     /tmp/ccVFpSmy.s:394    .text:0000000000000170 robotLedsOff
     /tmp/ccVFpSmy.s:423    .text:0000000000000188 bumperLedsNotif
     /tmp/ccVFpSmy.s:472    .text:00000000000001b4 drivePentagon
     /tmp/ccVFpSmy.s:486    .text:00000000000001b6 driveStraight

UNDEFINED SYMBOLS
byteTx
delayMs
byteRx
