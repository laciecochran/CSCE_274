   1               		.file	"iroblib.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	defineSongs
  12               	defineSongs:
  13               	.LFB0:
  14               		.file 1 "iroblib.c"
   1:iroblib.c     **** #include "iroblib.h"
   2:iroblib.c     **** #include "oi.h"
   3:iroblib.c     **** #include "cmod.h"
   4:iroblib.c     **** #include "timer.h"
   5:iroblib.c     **** 
   6:iroblib.c     **** // Define songs to be played later
   7:iroblib.c     **** void defineSongs(void) {
  15               		.loc 1 7 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
   8:iroblib.c     ****   // Reset song
   9:iroblib.c     ****   byteTx(CmdSong);
  21               		.loc 1 9 0
  22 0000 8CE8      		ldi r24,lo8(-116)
  23 0002 0E94 0000 		call byteTx
  24               	.LVL0:
  10:iroblib.c     ****   byteTx(RESET_SONG);
  25               		.loc 1 10 0
  26 0006 80E0      		ldi r24,0
  27 0008 0E94 0000 		call byteTx
  28               	.LVL1:
  11:iroblib.c     ****   byteTx(4);
  29               		.loc 1 11 0
  30 000c 84E0      		ldi r24,lo8(4)
  31 000e 0E94 0000 		call byteTx
  32               	.LVL2:
  12:iroblib.c     ****   byteTx(60);
  33               		.loc 1 12 0
  34 0012 8CE3      		ldi r24,lo8(60)
  35 0014 0E94 0000 		call byteTx
  36               	.LVL3:
  13:iroblib.c     ****   byteTx(6);
  37               		.loc 1 13 0
  38 0018 86E0      		ldi r24,lo8(6)
  39 001a 0E94 0000 		call byteTx
  40               	.LVL4:
  14:iroblib.c     ****   byteTx(72);
  41               		.loc 1 14 0
  42 001e 88E4      		ldi r24,lo8(72)
  43 0020 0E94 0000 		call byteTx
  44               	.LVL5:
  15:iroblib.c     ****   byteTx(6);
  45               		.loc 1 15 0
  46 0024 86E0      		ldi r24,lo8(6)
  47 0026 0E94 0000 		call byteTx
  48               	.LVL6:
  16:iroblib.c     ****   byteTx(84);
  49               		.loc 1 16 0
  50 002a 84E5      		ldi r24,lo8(84)
  51 002c 0E94 0000 		call byteTx
  52               	.LVL7:
  17:iroblib.c     ****   byteTx(6);
  53               		.loc 1 17 0
  54 0030 86E0      		ldi r24,lo8(6)
  55 0032 0E94 0000 		call byteTx
  56               	.LVL8:
  18:iroblib.c     ****   byteTx(96);
  57               		.loc 1 18 0
  58 0036 80E6      		ldi r24,lo8(96)
  59 0038 0E94 0000 		call byteTx
  60               	.LVL9:
  19:iroblib.c     ****   byteTx(6);
  61               		.loc 1 19 0
  62 003c 86E0      		ldi r24,lo8(6)
  63 003e 0E94 0000 		call byteTx
  64               	.LVL10:
  20:iroblib.c     **** 
  21:iroblib.c     ****   // Start song
  22:iroblib.c     ****   byteTx(CmdSong);
  65               		.loc 1 22 0
  66 0042 8CE8      		ldi r24,lo8(-116)
  67 0044 0E94 0000 		call byteTx
  68               	.LVL11:
  23:iroblib.c     ****   byteTx(START_SONG);
  69               		.loc 1 23 0
  70 0048 81E0      		ldi r24,lo8(1)
  71 004a 0E94 0000 		call byteTx
  72               	.LVL12:
  24:iroblib.c     ****   byteTx(6);
  73               		.loc 1 24 0
  74 004e 86E0      		ldi r24,lo8(6)
  75 0050 0E94 0000 		call byteTx
  76               	.LVL13:
  25:iroblib.c     ****   byteTx(69);
  77               		.loc 1 25 0
  78 0054 85E4      		ldi r24,lo8(69)
  79 0056 0E94 0000 		call byteTx
  80               	.LVL14:
  26:iroblib.c     ****   byteTx(18);
  81               		.loc 1 26 0
  82 005a 82E1      		ldi r24,lo8(18)
  83 005c 0E94 0000 		call byteTx
  84               	.LVL15:
  27:iroblib.c     ****   byteTx(72);
  85               		.loc 1 27 0
  86 0060 88E4      		ldi r24,lo8(72)
  87 0062 0E94 0000 		call byteTx
  88               	.LVL16:
  28:iroblib.c     ****   byteTx(12);
  89               		.loc 1 28 0
  90 0066 8CE0      		ldi r24,lo8(12)
  91 0068 0E94 0000 		call byteTx
  92               	.LVL17:
  29:iroblib.c     ****   byteTx(74);
  93               		.loc 1 29 0
  94 006c 8AE4      		ldi r24,lo8(74)
  95 006e 0E94 0000 		call byteTx
  96               	.LVL18:
  30:iroblib.c     ****   byteTx(12);
  97               		.loc 1 30 0
  98 0072 8CE0      		ldi r24,lo8(12)
  99 0074 0E94 0000 		call byteTx
 100               	.LVL19:
  31:iroblib.c     ****   byteTx(72);
 101               		.loc 1 31 0
 102 0078 88E4      		ldi r24,lo8(72)
 103 007a 0E94 0000 		call byteTx
 104               	.LVL20:
  32:iroblib.c     ****   byteTx(12);
 105               		.loc 1 32 0
 106 007e 8CE0      		ldi r24,lo8(12)
 107 0080 0E94 0000 		call byteTx
 108               	.LVL21:
  33:iroblib.c     ****   byteTx(69);
 109               		.loc 1 33 0
 110 0084 85E4      		ldi r24,lo8(69)
 111 0086 0E94 0000 		call byteTx
 112               	.LVL22:
  34:iroblib.c     ****   byteTx(12);
 113               		.loc 1 34 0
 114 008a 8CE0      		ldi r24,lo8(12)
 115 008c 0E94 0000 		call byteTx
 116               	.LVL23:
  35:iroblib.c     ****   byteTx(77);
 117               		.loc 1 35 0
 118 0090 8DE4      		ldi r24,lo8(77)
 119 0092 0E94 0000 		call byteTx
 120               	.LVL24:
  36:iroblib.c     ****   byteTx(24);
 121               		.loc 1 36 0
 122 0096 88E1      		ldi r24,lo8(24)
 123 0098 0C94 0000 		jmp byteTx
 124               	.LVL25:
 125               		.cfi_endproc
 126               	.LFE0:
 128               	.global	powerOnRobot
 130               	powerOnRobot:
 131               	.LFB1:
  37:iroblib.c     **** }
  38:iroblib.c     **** 
  39:iroblib.c     **** // Ensure that the robot is On.
  40:iroblib.c     **** void powerOnRobot(void) {
 132               		.loc 1 40 0
 133               		.cfi_startproc
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
  41:iroblib.c     ****   // If Create's power is off, turn it on
  42:iroblib.c     ****   if(!RobotIsOn) {
 138               		.loc 1 42 0
 139 009c 1D99      		sbic 0x3,5
 140 009e 00C0      		rjmp .L7
 141               	.L4:
  43:iroblib.c     ****     while(!RobotIsOn) {
 142               		.loc 1 43 0 discriminator 1
 143 00a0 1D99      		sbic 0x3,5
 144 00a2 00C0      		rjmp .L12
  44:iroblib.c     ****       RobotPwrToggleLow;
 145               		.loc 1 44 0
 146 00a4 5F98      		cbi 0xb,7
  45:iroblib.c     ****       delayMs(500);  // Delay in this state
 147               		.loc 1 45 0
 148 00a6 84EF      		ldi r24,lo8(-12)
 149 00a8 91E0      		ldi r25,lo8(1)
 150 00aa 0E94 0000 		call delayMs
 151               	.LVL26:
  46:iroblib.c     ****       RobotPwrToggleHigh;  // Low to high transition to toggle power
 152               		.loc 1 46 0
 153 00ae 5F9A      		sbi 0xb,7
  47:iroblib.c     ****       delayMs(100);  // Delay in this state
 154               		.loc 1 47 0
 155 00b0 84E6      		ldi r24,lo8(100)
 156 00b2 90E0      		ldi r25,0
 157 00b4 0E94 0000 		call delayMs
 158               	.LVL27:
  48:iroblib.c     ****       RobotPwrToggleLow;
 159               		.loc 1 48 0
 160 00b8 5F98      		cbi 0xb,7
 161 00ba 00C0      		rjmp .L4
 162               	.L12:
  49:iroblib.c     ****     }
  50:iroblib.c     ****     delayMs(3500);  // Delay for startup
 163               		.loc 1 50 0
 164 00bc 8CEA      		ldi r24,lo8(-84)
 165 00be 9DE0      		ldi r25,lo8(13)
 166 00c0 0E94 0000 		call delayMs
 167               	.LVL28:
 168               	.L7:
  51:iroblib.c     ****   }
  52:iroblib.c     **** 
  53:iroblib.c     ****   // Flush the buffer
  54:iroblib.c     ****   while( (UCSR0A & 0x80) && UDR0);
 169               		.loc 1 54 0 discriminator 1
 170 00c4 8091 C000 		lds r24,192
 171 00c8 87FF      		sbrs r24,7
 172 00ca 00C0      		rjmp .L2
 173               		.loc 1 54 0 is_stmt 0 discriminator 2
 174 00cc 8091 C600 		lds r24,198
 175 00d0 8111      		cpse r24,__zero_reg__
 176 00d2 00C0      		rjmp .L7
 177               	.L2:
 178 00d4 0895      		ret
 179               		.cfi_endproc
 180               	.LFE1:
 182               	.global	powerOffRobot
 184               	powerOffRobot:
 185               	.LFB2:
  55:iroblib.c     **** }
  56:iroblib.c     **** 
  57:iroblib.c     **** // Ensure that the robot is OFF.
  58:iroblib.c     **** void powerOffRobot(void) {
 186               		.loc 1 58 0 is_stmt 1
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
  59:iroblib.c     ****   // If Create's power is on, turn it off
  60:iroblib.c     ****   if(RobotIsOn) {
 192               		.loc 1 60 0
 193 00d6 1D9B      		sbis 0x3,5
 194 00d8 0895      		ret
 195               	.L18:
  61:iroblib.c     ****     while(RobotIsOn) {
 196               		.loc 1 61 0 discriminator 1
 197 00da 1D9B      		sbis 0x3,5
 198 00dc 00C0      		rjmp .L19
  62:iroblib.c     ****       RobotPwrToggleLow;
 199               		.loc 1 62 0
 200 00de 5F98      		cbi 0xb,7
  63:iroblib.c     ****       delayMs(500);  // Delay in this state
 201               		.loc 1 63 0
 202 00e0 84EF      		ldi r24,lo8(-12)
 203 00e2 91E0      		ldi r25,lo8(1)
 204 00e4 0E94 0000 		call delayMs
 205               	.LVL29:
  64:iroblib.c     ****       RobotPwrToggleHigh;  // Low to high transition to toggle power
 206               		.loc 1 64 0
 207 00e8 5F9A      		sbi 0xb,7
  65:iroblib.c     ****       delayMs(100);  // Delay in this state
 208               		.loc 1 65 0
 209 00ea 84E6      		ldi r24,lo8(100)
 210 00ec 90E0      		ldi r25,0
 211 00ee 0E94 0000 		call delayMs
 212               	.LVL30:
  66:iroblib.c     ****       RobotPwrToggleLow;
 213               		.loc 1 66 0
 214 00f2 5F98      		cbi 0xb,7
 215 00f4 00C0      		rjmp .L18
 216               	.L19:
 217 00f6 0895      		ret
 218               		.cfi_endproc
 219               	.LFE2:
 221               	.global	powerLed
 223               	powerLed:
 224               	.LFB3:
  67:iroblib.c     ****     }
  68:iroblib.c     ****   }
  69:iroblib.c     **** }
  70:iroblib.c     **** 
  71:iroblib.c     **** //Turn on power Led given a specified color.
  72:iroblib.c     **** void powerLed(uint8_t color) {
 225               		.loc 1 72 0
 226               		.cfi_startproc
 227               	.LVL31:
 228 00f8 CF93      		push r28
 229               	.LCFI0:
 230               		.cfi_def_cfa_offset 3
 231               		.cfi_offset 28, -2
 232               	/* prologue: function */
 233               	/* frame size = 0 */
 234               	/* stack size = 1 */
 235               	.L__stack_usage = 1
 236 00fa C82F      		mov r28,r24
  73:iroblib.c     **** 
  74:iroblib.c     ****   byteTx(CmdLeds); 
 237               		.loc 1 74 0
 238 00fc 8BE8      		ldi r24,lo8(-117)
 239               	.LVL32:
 240 00fe 0E94 0000 		call byteTx
 241               	.LVL33:
  75:iroblib.c     ****   byteTx(0x00); //both robot Leds off
 242               		.loc 1 75 0
 243 0102 80E0      		ldi r24,0
 244 0104 0E94 0000 		call byteTx
 245               	.LVL34:
  76:iroblib.c     ****   byteTx(color);
 246               		.loc 1 76 0
 247 0108 8C2F      		mov r24,r28
 248 010a 0E94 0000 		call byteTx
 249               	.LVL35:
  77:iroblib.c     ****   byteTx(255); //intensity
 250               		.loc 1 77 0
 251 010e 8FEF      		ldi r24,lo8(-1)
 252               	/* epilogue start */
  78:iroblib.c     **** 
  79:iroblib.c     **** }
 253               		.loc 1 79 0
 254 0110 CF91      		pop r28
 255               	.LVL36:
  77:iroblib.c     ****   byteTx(255); //intensity
 256               		.loc 1 77 0
 257 0112 0C94 0000 		jmp byteTx
 258               	.LVL37:
 259               		.cfi_endproc
 260               	.LFE3:
 262               	.global	setupCMDLeds
 264               	setupCMDLeds:
 265               	.LFB4:
  80:iroblib.c     **** 
  81:iroblib.c     **** //Setup the command module Leds
  82:iroblib.c     **** void setupCMDLeds(void) {
 266               		.loc 1 82 0
 267               		.cfi_startproc
 268               	/* prologue: function */
 269               	/* frame size = 0 */
 270               	/* stack size = 0 */
 271               	.L__stack_usage = 0
  83:iroblib.c     **** 
  84:iroblib.c     ****   //Set fifth and sixth bits of direction register of port D to 1.
  85:iroblib.c     ****   //pin 5 controls right Led, pin 6 controls left Led
  86:iroblib.c     ****   DDRD |= (3 << 5);
 272               		.loc 1 86 0
 273 0116 8AB1      		in r24,0xa
 274 0118 8066      		ori r24,lo8(96)
 275 011a 8AB9      		out 0xa,r24
 276 011c 0895      		ret
 277               		.cfi_endproc
 278               	.LFE4:
 280               	.global	toggleCMDLeds
 282               	toggleCMDLeds:
 283               	.LFB5:
  87:iroblib.c     **** 
  88:iroblib.c     **** }
  89:iroblib.c     **** 
  90:iroblib.c     **** //Toggle the command module Leds
  91:iroblib.c     **** void toggleCMDLeds(void) {
 284               		.loc 1 91 0
 285               		.cfi_startproc
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	/* stack size = 0 */
 289               	.L__stack_usage = 0
  92:iroblib.c     ****   //turn the Leds off/on using exclusive or
  93:iroblib.c     ****   
  94:iroblib.c     ****   PORTD ^= (3 << 5);
 290               		.loc 1 94 0
 291 011e 8BB1      		in r24,0xb
 292 0120 90E6      		ldi r25,lo8(96)
 293 0122 8927      		eor r24,r25
 294 0124 8BB9      		out 0xb,r24
 295 0126 0895      		ret
 296               		.cfi_endproc
 297               	.LFE5:
 299               	.global	robotLeftLedOn
 301               	robotLeftLedOn:
 302               	.LFB7:
  95:iroblib.c     **** 
  96:iroblib.c     **** }
  97:iroblib.c     **** 
  98:iroblib.c     **** //Detect left or right bumper. Set corresponding Led
  99:iroblib.c     **** void bumperLedsNotif(void) {
 100:iroblib.c     **** 
 101:iroblib.c     ****   //Ask about bump sensors
 102:iroblib.c     ****   byteTx(CmdSensors); //"read sensors"
 103:iroblib.c     ****   byteTx(7); //sensor packet 7 for bumps and wheels
 104:iroblib.c     **** 
 105:iroblib.c     ****   //read response and extract relevant information
 106:iroblib.c     ****   uint8_t bumps = byteRx();
 107:iroblib.c     ****   uint8_t bumpRight = bumps & (1 << 0);
 108:iroblib.c     ****   uint8_t bumpLeft  = bumps & (1 << 1);
 109:iroblib.c     **** 
 110:iroblib.c     ****   //set robot Leds
 111:iroblib.c     ****   if(bumpLeft && bumpRight) {robotLedsOn();}
 112:iroblib.c     ****   else if(bumpLeft) {robotLeftLedOn();}
 113:iroblib.c     ****   else if(bumpRight) {robotRightLedOn();}
 114:iroblib.c     ****   else {robotLedsOff();}
 115:iroblib.c     **** 
 116:iroblib.c     **** }
 117:iroblib.c     **** 
 118:iroblib.c     **** //Turn on robot's left Led
 119:iroblib.c     **** void robotLeftLedOn(void) {
 303               		.loc 1 119 0
 304               		.cfi_startproc
 305               	/* prologue: function */
 306               	/* frame size = 0 */
 307               	/* stack size = 0 */
 308               	.L__stack_usage = 0
 120:iroblib.c     **** 
 121:iroblib.c     ****   byteTx(CmdLeds); 
 309               		.loc 1 121 0
 310 0128 8BE8      		ldi r24,lo8(-117)
 311 012a 0E94 0000 		call byteTx
 312               	.LVL38:
 122:iroblib.c     ****   byteTx(0x02); //
 313               		.loc 1 122 0
 314 012e 82E0      		ldi r24,lo8(2)
 315 0130 0E94 0000 		call byteTx
 316               	.LVL39:
 123:iroblib.c     ****   byteTx(0);
 317               		.loc 1 123 0
 318 0134 80E0      		ldi r24,0
 319 0136 0E94 0000 		call byteTx
 320               	.LVL40:
 124:iroblib.c     ****   byteTx(255); //intensity
 321               		.loc 1 124 0
 322 013a 8FEF      		ldi r24,lo8(-1)
 323 013c 0C94 0000 		jmp byteTx
 324               	.LVL41:
 325               		.cfi_endproc
 326               	.LFE7:
 328               	.global	robotRightLedOn
 330               	robotRightLedOn:
 331               	.LFB8:
 125:iroblib.c     **** 
 126:iroblib.c     **** }
 127:iroblib.c     **** 
 128:iroblib.c     **** //Turn on robot's right Led
 129:iroblib.c     **** void robotRightLedOn(void) {
 332               		.loc 1 129 0
 333               		.cfi_startproc
 334               	/* prologue: function */
 335               	/* frame size = 0 */
 336               	/* stack size = 0 */
 337               	.L__stack_usage = 0
 130:iroblib.c     **** 
 131:iroblib.c     ****   byteTx(CmdLeds); 
 338               		.loc 1 131 0
 339 0140 8BE8      		ldi r24,lo8(-117)
 340 0142 0E94 0000 		call byteTx
 341               	.LVL42:
 132:iroblib.c     ****   byteTx(0x08); //
 342               		.loc 1 132 0
 343 0146 88E0      		ldi r24,lo8(8)
 344 0148 0E94 0000 		call byteTx
 345               	.LVL43:
 133:iroblib.c     ****   byteTx(0);
 346               		.loc 1 133 0
 347 014c 80E0      		ldi r24,0
 348 014e 0E94 0000 		call byteTx
 349               	.LVL44:
 134:iroblib.c     ****   byteTx(255); //intensity
 350               		.loc 1 134 0
 351 0152 8FEF      		ldi r24,lo8(-1)
 352 0154 0C94 0000 		jmp byteTx
 353               	.LVL45:
 354               		.cfi_endproc
 355               	.LFE8:
 357               	.global	robotLedsOn
 359               	robotLedsOn:
 360               	.LFB9:
 135:iroblib.c     **** 
 136:iroblib.c     **** }
 137:iroblib.c     **** //Turn on both play and advance Leds
 138:iroblib.c     **** void robotLedsOn(void) {
 361               		.loc 1 138 0
 362               		.cfi_startproc
 363               	/* prologue: function */
 364               	/* frame size = 0 */
 365               	/* stack size = 0 */
 366               	.L__stack_usage = 0
 139:iroblib.c     **** 
 140:iroblib.c     ****   byteTx(CmdLeds);
 367               		.loc 1 140 0
 368 0158 8BE8      		ldi r24,lo8(-117)
 369 015a 0E94 0000 		call byteTx
 370               	.LVL46:
 141:iroblib.c     ****   byteTx(0x0a);
 371               		.loc 1 141 0
 372 015e 8AE0      		ldi r24,lo8(10)
 373 0160 0E94 0000 		call byteTx
 374               	.LVL47:
 142:iroblib.c     ****   byteTx(0);
 375               		.loc 1 142 0
 376 0164 80E0      		ldi r24,0
 377 0166 0E94 0000 		call byteTx
 378               	.LVL48:
 143:iroblib.c     ****   byteTx(255);
 379               		.loc 1 143 0
 380 016a 8FEF      		ldi r24,lo8(-1)
 381 016c 0C94 0000 		jmp byteTx
 382               	.LVL49:
 383               		.cfi_endproc
 384               	.LFE9:
 386               	.global	robotLedsOff
 388               	robotLedsOff:
 389               	.LFB10:
 144:iroblib.c     **** 
 145:iroblib.c     **** }
 146:iroblib.c     **** 
 147:iroblib.c     **** //Turn off robot's left Led
 148:iroblib.c     **** void robotLedsOff(void) {
 390               		.loc 1 148 0
 391               		.cfi_startproc
 392               	/* prologue: function */
 393               	/* frame size = 0 */
 394               	/* stack size = 0 */
 395               	.L__stack_usage = 0
 149:iroblib.c     **** 
 150:iroblib.c     ****   byteTx(CmdLeds); 
 396               		.loc 1 150 0
 397 0170 8BE8      		ldi r24,lo8(-117)
 398 0172 0E94 0000 		call byteTx
 399               	.LVL50:
 151:iroblib.c     ****   byteTx(0x00); //
 400               		.loc 1 151 0
 401 0176 80E0      		ldi r24,0
 402 0178 0E94 0000 		call byteTx
 403               	.LVL51:
 152:iroblib.c     ****   byteTx(0);
 404               		.loc 1 152 0
 405 017c 80E0      		ldi r24,0
 406 017e 0E94 0000 		call byteTx
 407               	.LVL52:
 153:iroblib.c     ****   byteTx(255);
 408               		.loc 1 153 0
 409 0182 8FEF      		ldi r24,lo8(-1)
 410 0184 0C94 0000 		jmp byteTx
 411               	.LVL53:
 412               		.cfi_endproc
 413               	.LFE10:
 415               	.global	bumperLedsNotif
 417               	bumperLedsNotif:
 418               	.LFB6:
  99:iroblib.c     **** void bumperLedsNotif(void) {
 419               		.loc 1 99 0
 420               		.cfi_startproc
 421               	/* prologue: function */
 422               	/* frame size = 0 */
 423               	/* stack size = 0 */
 424               	.L__stack_usage = 0
 102:iroblib.c     ****   byteTx(CmdSensors); //"read sensors"
 425               		.loc 1 102 0
 426 0188 8EE8      		ldi r24,lo8(-114)
 427 018a 0E94 0000 		call byteTx
 428               	.LVL54:
 103:iroblib.c     ****   byteTx(7); //sensor packet 7 for bumps and wheels
 429               		.loc 1 103 0
 430 018e 87E0      		ldi r24,lo8(7)
 431 0190 0E94 0000 		call byteTx
 432               	.LVL55:
 106:iroblib.c     ****   uint8_t bumps = byteRx();
 433               		.loc 1 106 0
 434 0194 0E94 0000 		call byteRx
 435               	.LVL56:
 107:iroblib.c     ****   uint8_t bumpRight = bumps & (1 << 0);
 436               		.loc 1 107 0
 437 0198 982F      		mov r25,r24
 438 019a 9170      		andi r25,lo8(1)
 439               	.LVL57:
 111:iroblib.c     ****   if(bumpLeft && bumpRight) {robotLedsOn();}
 440               		.loc 1 111 0
 441 019c 81FF      		sbrs r24,1
 442 019e 00C0      		rjmp .L28
 111:iroblib.c     ****   if(bumpLeft && bumpRight) {robotLedsOn();}
 443               		.loc 1 111 0 is_stmt 0 discriminator 1
 444 01a0 9111      		cpse r25,__zero_reg__
 445 01a2 0C94 0000 		jmp robotLedsOn
 446               	.LVL58:
 447               	.L29:
 112:iroblib.c     ****   else if(bumpLeft) {robotLeftLedOn();}
 448               		.loc 1 112 0 is_stmt 1 discriminator 1
 449 01a6 0C94 0000 		jmp robotLeftLedOn
 450               	.LVL59:
 451               	.L28:
 113:iroblib.c     ****   else if(bumpRight) {robotRightLedOn();}
 452               		.loc 1 113 0
 453 01aa 9111      		cpse r25,__zero_reg__
 113:iroblib.c     ****   else if(bumpRight) {robotRightLedOn();}
 454               		.loc 1 113 0 is_stmt 0 discriminator 1
 455 01ac 0C94 0000 		jmp robotRightLedOn
 456               	.LVL60:
 457               	.L30:
 114:iroblib.c     ****   else {robotLedsOff();}
 458               		.loc 1 114 0 is_stmt 1
 459 01b0 0C94 0000 		jmp robotLedsOff
 460               	.LVL61:
 461               		.cfi_endproc
 462               	.LFE6:
 464               	.global	drivePentagonCCW
 466               	drivePentagonCCW:
 467               	.LFB13:
 154:iroblib.c     **** }
 155:iroblib.c     **** 
 156:iroblib.c     **** //detect the play and advance buttons
 157:iroblib.c     **** void buttonDetect(void) {
 158:iroblib.c     **** 
 159:iroblib.c     ****   //Ask about bump sensors
 160:iroblib.c     ****   byteTx(CmdSensors); //"read sensors"
 161:iroblib.c     ****   byteTx(18); //sensor packet 18 for play and advance buttons
 162:iroblib.c     **** 
 163:iroblib.c     ****   uint8_t buttons = byteRx();
 164:iroblib.c     ****   uint8_t play = buttons & (1 << 0);
 165:iroblib.c     ****   uint8_t advance  = buttons & (1 << 2);
 166:iroblib.c     **** 
 167:iroblib.c     ****   if(play) {drivePentagonCW();}
 168:iroblib.c     ****   else if(advance) {rotate(~V, V);delayMs(1750);}
 169:iroblib.c     ****   else {stopCreate();}
 170:iroblib.c     **** 
 171:iroblib.c     **** 
 172:iroblib.c     **** }
 173:iroblib.c     **** 
 174:iroblib.c     **** //drive the create around a pentagon clockwise
 175:iroblib.c     **** //vl needs to be positive
 176:iroblib.c     **** void drivePentagonCW(void) {
 177:iroblib.c     **** 
 178:iroblib.c     ****   for(uint8_t numRotates = 0; numRotates < 5; numRotates++) {
 179:iroblib.c     **** 
 180:iroblib.c     ****     driveStraight(V, V);
 181:iroblib.c     ****     delayMs(8400);
 182:iroblib.c     ****     stopCreate();
 183:iroblib.c     ****     rotate(~V, V);
 184:iroblib.c     ****     delayMs(1715);
 185:iroblib.c     ****     stopCreate();
 186:iroblib.c     ****   }
 187:iroblib.c     **** 
 188:iroblib.c     ****   
 189:iroblib.c     **** 
 190:iroblib.c     **** }
 191:iroblib.c     **** 
 192:iroblib.c     **** //drive the create around a pentagon counter clockwise
 193:iroblib.c     **** void drivePentagonCCW(void) {
 468               		.loc 1 193 0
 469               		.cfi_startproc
 470               	/* prologue: function */
 471               	/* frame size = 0 */
 472               	/* stack size = 0 */
 473               	.L__stack_usage = 0
 474 01b4 0895      		ret
 475               		.cfi_endproc
 476               	.LFE13:
 478               	.global	driveStraight
 480               	driveStraight:
 481               	.LFB14:
 194:iroblib.c     **** 
 195:iroblib.c     ****   
 196:iroblib.c     **** 
 197:iroblib.c     **** }
 198:iroblib.c     **** 
 199:iroblib.c     **** 
 200:iroblib.c     **** //drive create straight for a specified distance
 201:iroblib.c     **** void driveStraight(uint16_t vr, uint16_t vl) {
 482               		.loc 1 201 0
 483               		.cfi_startproc
 484               	.LVL62:
 485               		.loc 1 201 0
 486 01b6 1F93      		push r17
 487               	.LCFI1:
 488               		.cfi_def_cfa_offset 3
 489               		.cfi_offset 17, -2
 490 01b8 CF93      		push r28
 491               	.LCFI2:
 492               		.cfi_def_cfa_offset 4
 493               		.cfi_offset 28, -3
 494 01ba DF93      		push r29
 495               	.LCFI3:
 496               		.cfi_def_cfa_offset 5
 497               		.cfi_offset 29, -4
 498 01bc 00D0      		rcall .
 499 01be 1F92      		push __zero_reg__
 500               	.LCFI4:
 501               		.cfi_def_cfa_offset 8
 502 01c0 CDB7      		in r28,__SP_L__
 503 01c2 DEB7      		in r29,__SP_H__
 504               	.LCFI5:
 505               		.cfi_def_cfa_register 28
 506               	/* prologue: function */
 507               	/* frame size = 3 */
 508               	/* stack size = 6 */
 509               	.L__stack_usage = 6
 510 01c4 182F      		mov r17,r24
 202:iroblib.c     **** 
 203:iroblib.c     ****   byteTx(CmdDriveWheels);
 511               		.loc 1 203 0
 512 01c6 81E9      		ldi r24,lo8(-111)
 513               	.LVL63:
 514 01c8 6B83      		std Y+3,r22
 515 01ca 7A83      		std Y+2,r23
 516 01cc 9983      		std Y+1,r25
 517 01ce 0E94 0000 		call byteTx
 518               	.LVL64:
 204:iroblib.c     ****   byteTx((vr>>8)&0xFF);
 519               		.loc 1 204 0
 520 01d2 9981      		ldd r25,Y+1
 521 01d4 892F      		mov r24,r25
 522 01d6 0E94 0000 		call byteTx
 523               	.LVL65:
 205:iroblib.c     ****   byteTx(vr&0xFF);
 524               		.loc 1 205 0
 525 01da 812F      		mov r24,r17
 526 01dc 0E94 0000 		call byteTx
 527               	.LVL66:
 206:iroblib.c     ****   byteTx((vl>>8)&0xFF);
 528               		.loc 1 206 0
 529 01e0 7A81      		ldd r23,Y+2
 530 01e2 872F      		mov r24,r23
 531 01e4 0E94 0000 		call byteTx
 532               	.LVL67:
 207:iroblib.c     ****   byteTx(vl&0xFF);
 533               		.loc 1 207 0
 534 01e8 6B81      		ldd r22,Y+3
 535 01ea 862F      		mov r24,r22
 536               	/* epilogue start */
 208:iroblib.c     **** }
 537               		.loc 1 208 0
 538 01ec 0F90      		pop __tmp_reg__
 539 01ee 0F90      		pop __tmp_reg__
 540 01f0 0F90      		pop __tmp_reg__
 541 01f2 DF91      		pop r29
 542 01f4 CF91      		pop r28
 543 01f6 1F91      		pop r17
 207:iroblib.c     ****   byteTx(vl&0xFF);
 544               		.loc 1 207 0
 545 01f8 0C94 0000 		jmp byteTx
 546               	.LVL68:
 547               		.cfi_endproc
 548               	.LFE14:
 550               	.global	rotate
 552               	rotate:
 553               	.LFB15:
 209:iroblib.c     **** 
 210:iroblib.c     **** void rotate(uint16_t vr, uint16_t vl) {
 554               		.loc 1 210 0
 555               		.cfi_startproc
 556               	.LVL69:
 557 01fc 1F93      		push r17
 558               	.LCFI6:
 559               		.cfi_def_cfa_offset 3
 560               		.cfi_offset 17, -2
 561 01fe CF93      		push r28
 562               	.LCFI7:
 563               		.cfi_def_cfa_offset 4
 564               		.cfi_offset 28, -3
 565 0200 DF93      		push r29
 566               	.LCFI8:
 567               		.cfi_def_cfa_offset 5
 568               		.cfi_offset 29, -4
 569 0202 00D0      		rcall .
 570 0204 1F92      		push __zero_reg__
 571               	.LCFI9:
 572               		.cfi_def_cfa_offset 8
 573 0206 CDB7      		in r28,__SP_L__
 574 0208 DEB7      		in r29,__SP_H__
 575               	.LCFI10:
 576               		.cfi_def_cfa_register 28
 577               	/* prologue: function */
 578               	/* frame size = 3 */
 579               	/* stack size = 6 */
 580               	.L__stack_usage = 6
 581 020a 182F      		mov r17,r24
 211:iroblib.c     **** 
 212:iroblib.c     ****   byteTx(CmdDriveWheels);
 582               		.loc 1 212 0
 583 020c 81E9      		ldi r24,lo8(-111)
 584               	.LVL70:
 585 020e 6B83      		std Y+3,r22
 586 0210 7A83      		std Y+2,r23
 587 0212 9983      		std Y+1,r25
 588 0214 0E94 0000 		call byteTx
 589               	.LVL71:
 213:iroblib.c     ****   byteTx((vr>>8)&0xFF);
 590               		.loc 1 213 0
 591 0218 9981      		ldd r25,Y+1
 592 021a 892F      		mov r24,r25
 593 021c 0E94 0000 		call byteTx
 594               	.LVL72:
 214:iroblib.c     ****   byteTx(vr&0xFF);
 595               		.loc 1 214 0
 596 0220 812F      		mov r24,r17
 597 0222 0E94 0000 		call byteTx
 598               	.LVL73:
 215:iroblib.c     ****   byteTx((vl>>8)&0xFF);
 599               		.loc 1 215 0
 600 0226 7A81      		ldd r23,Y+2
 601 0228 872F      		mov r24,r23
 602 022a 0E94 0000 		call byteTx
 603               	.LVL74:
 216:iroblib.c     ****   byteTx(vl&0xFF);
 604               		.loc 1 216 0
 605 022e 6B81      		ldd r22,Y+3
 606 0230 862F      		mov r24,r22
 607               	/* epilogue start */
 217:iroblib.c     **** 
 218:iroblib.c     **** }
 608               		.loc 1 218 0
 609 0232 0F90      		pop __tmp_reg__
 610 0234 0F90      		pop __tmp_reg__
 611 0236 0F90      		pop __tmp_reg__
 612 0238 DF91      		pop r29
 613 023a CF91      		pop r28
 614 023c 1F91      		pop r17
 216:iroblib.c     ****   byteTx(vl&0xFF);
 615               		.loc 1 216 0
 616 023e 0C94 0000 		jmp byteTx
 617               	.LVL75:
 618               		.cfi_endproc
 619               	.LFE15:
 621               	.global	stopCreate
 623               	stopCreate:
 624               	.LFB16:
 219:iroblib.c     **** 
 220:iroblib.c     **** void stopCreate(void) {
 625               		.loc 1 220 0
 626               		.cfi_startproc
 627               	/* prologue: function */
 628               	/* frame size = 0 */
 629               	/* stack size = 0 */
 630               	.L__stack_usage = 0
 221:iroblib.c     **** 
 222:iroblib.c     ****   byteTx(CmdDriveWheels);
 631               		.loc 1 222 0
 632 0242 81E9      		ldi r24,lo8(-111)
 633 0244 0E94 0000 		call byteTx
 634               	.LVL76:
 223:iroblib.c     ****   byteTx(0);
 635               		.loc 1 223 0
 636 0248 80E0      		ldi r24,0
 637 024a 0E94 0000 		call byteTx
 638               	.LVL77:
 224:iroblib.c     ****   byteTx(0);
 639               		.loc 1 224 0
 640 024e 80E0      		ldi r24,0
 641 0250 0E94 0000 		call byteTx
 642               	.LVL78:
 225:iroblib.c     ****   byteTx(0);
 643               		.loc 1 225 0
 644 0254 80E0      		ldi r24,0
 645 0256 0E94 0000 		call byteTx
 646               	.LVL79:
 226:iroblib.c     ****   byteTx(0);
 647               		.loc 1 226 0
 648 025a 80E0      		ldi r24,0
 649 025c 0C94 0000 		jmp byteTx
 650               	.LVL80:
 651               		.cfi_endproc
 652               	.LFE16:
 654               	.global	drivePentagonCW
 656               	drivePentagonCW:
 657               	.LFB12:
 176:iroblib.c     **** void drivePentagonCW(void) {
 658               		.loc 1 176 0
 659               		.cfi_startproc
 660 0260 CF93      		push r28
 661               	.LCFI11:
 662               		.cfi_def_cfa_offset 3
 663               		.cfi_offset 28, -2
 664               	/* prologue: function */
 665               	/* frame size = 0 */
 666               	/* stack size = 1 */
 667               	.L__stack_usage = 1
 668               	.LVL81:
 176:iroblib.c     **** void drivePentagonCW(void) {
 669               		.loc 1 176 0
 670 0262 C5E0      		ldi r28,lo8(5)
 671               	.LVL82:
 672               	.L37:
 673               	.LBB2:
 180:iroblib.c     ****     driveStraight(V, V);
 674               		.loc 1 180 0 discriminator 2
 675 0264 64E6      		ldi r22,lo8(100)
 676 0266 70E0      		ldi r23,0
 677 0268 84E6      		ldi r24,lo8(100)
 678 026a 90E0      		ldi r25,0
 679 026c 0E94 0000 		call driveStraight
 680               	.LVL83:
 181:iroblib.c     ****     delayMs(8400);
 681               		.loc 1 181 0 discriminator 2
 682 0270 80ED      		ldi r24,lo8(-48)
 683 0272 90E2      		ldi r25,lo8(32)
 684 0274 0E94 0000 		call delayMs
 685               	.LVL84:
 182:iroblib.c     ****     stopCreate();
 686               		.loc 1 182 0 discriminator 2
 687 0278 0E94 0000 		call stopCreate
 688               	.LVL85:
 183:iroblib.c     ****     rotate(~V, V);
 689               		.loc 1 183 0 discriminator 2
 690 027c 64E6      		ldi r22,lo8(100)
 691 027e 70E0      		ldi r23,0
 692 0280 8BE9      		ldi r24,lo8(-101)
 693 0282 9FEF      		ldi r25,lo8(-1)
 694 0284 0E94 0000 		call rotate
 695               	.LVL86:
 184:iroblib.c     ****     delayMs(1715);
 696               		.loc 1 184 0 discriminator 2
 697 0288 83EB      		ldi r24,lo8(-77)
 698 028a 96E0      		ldi r25,lo8(6)
 699 028c 0E94 0000 		call delayMs
 700               	.LVL87:
 185:iroblib.c     ****     stopCreate();
 701               		.loc 1 185 0 discriminator 2
 702 0290 0E94 0000 		call stopCreate
 703               	.LVL88:
 704 0294 C150      		subi r28,lo8(-(-1))
 705               	.LVL89:
 178:iroblib.c     ****   for(uint8_t numRotates = 0; numRotates < 5; numRotates++) {
 706               		.loc 1 178 0 discriminator 2
 707 0296 01F4      		brne .L37
 708               	/* epilogue start */
 709               	.LBE2:
 190:iroblib.c     **** }
 710               		.loc 1 190 0
 711 0298 CF91      		pop r28
 712               	.LVL90:
 713 029a 0895      		ret
 714               		.cfi_endproc
 715               	.LFE12:
 717               	.global	buttonDetect
 719               	buttonDetect:
 720               	.LFB11:
 157:iroblib.c     **** void buttonDetect(void) {
 721               		.loc 1 157 0
 722               		.cfi_startproc
 723               	/* prologue: function */
 724               	/* frame size = 0 */
 725               	/* stack size = 0 */
 726               	.L__stack_usage = 0
 160:iroblib.c     ****   byteTx(CmdSensors); //"read sensors"
 727               		.loc 1 160 0
 728 029c 8EE8      		ldi r24,lo8(-114)
 729 029e 0E94 0000 		call byteTx
 730               	.LVL91:
 161:iroblib.c     ****   byteTx(18); //sensor packet 18 for play and advance buttons
 731               		.loc 1 161 0
 732 02a2 82E1      		ldi r24,lo8(18)
 733 02a4 0E94 0000 		call byteTx
 734               	.LVL92:
 163:iroblib.c     ****   uint8_t buttons = byteRx();
 735               		.loc 1 163 0
 736 02a8 0E94 0000 		call byteRx
 737               	.LVL93:
 165:iroblib.c     ****   uint8_t advance  = buttons & (1 << 2);
 738               		.loc 1 165 0
 739 02ac 982F      		mov r25,r24
 740 02ae 9470      		andi r25,lo8(4)
 741               	.LVL94:
 167:iroblib.c     ****   if(play) {drivePentagonCW();}
 742               		.loc 1 167 0
 743 02b0 80FD      		sbrc r24,0
 167:iroblib.c     ****   if(play) {drivePentagonCW();}
 744               		.loc 1 167 0 is_stmt 0 discriminator 1
 745 02b2 0C94 0000 		jmp drivePentagonCW
 746               	.LVL95:
 747               	.L39:
 168:iroblib.c     ****   else if(advance) {rotate(~V, V);delayMs(1750);}
 748               		.loc 1 168 0 is_stmt 1
 749 02b6 9923      		tst r25
 750 02b8 01F0      		breq .L40
 168:iroblib.c     ****   else if(advance) {rotate(~V, V);delayMs(1750);}
 751               		.loc 1 168 0 is_stmt 0 discriminator 1
 752 02ba 64E6      		ldi r22,lo8(100)
 753 02bc 70E0      		ldi r23,0
 754 02be 8BE9      		ldi r24,lo8(-101)
 755 02c0 9FEF      		ldi r25,lo8(-1)
 756               	.LVL96:
 757 02c2 0E94 0000 		call rotate
 758               	.LVL97:
 759 02c6 86ED      		ldi r24,lo8(-42)
 760 02c8 96E0      		ldi r25,lo8(6)
 761 02ca 0C94 0000 		jmp delayMs
 762               	.LVL98:
 763               	.L40:
 169:iroblib.c     ****   else {stopCreate();}
 764               		.loc 1 169 0 is_stmt 1
 765 02ce 0C94 0000 		jmp stopCreate
 766               	.LVL99:
 767               		.cfi_endproc
 768               	.LFE11:
 770               	.Letext0:
 771               		.file 2 "/usr/lib/avr/include/stdint.h"
 772               		.file 3 "cmod.h"
 773               		.file 4 "timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 iroblib.c
     /tmp/ccqLPhZF.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccqLPhZF.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccqLPhZF.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccqLPhZF.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccqLPhZF.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccqLPhZF.s:12     .text:0000000000000000 defineSongs
     /tmp/ccqLPhZF.s:130    .text:000000000000009c powerOnRobot
     /tmp/ccqLPhZF.s:184    .text:00000000000000d6 powerOffRobot
     /tmp/ccqLPhZF.s:223    .text:00000000000000f8 powerLed
     /tmp/ccqLPhZF.s:264    .text:0000000000000116 setupCMDLeds
     /tmp/ccqLPhZF.s:282    .text:000000000000011e toggleCMDLeds
     /tmp/ccqLPhZF.s:301    .text:0000000000000128 robotLeftLedOn
     /tmp/ccqLPhZF.s:330    .text:0000000000000140 robotRightLedOn
     /tmp/ccqLPhZF.s:359    .text:0000000000000158 robotLedsOn
     /tmp/ccqLPhZF.s:388    .text:0000000000000170 robotLedsOff
     /tmp/ccqLPhZF.s:417    .text:0000000000000188 bumperLedsNotif
     /tmp/ccqLPhZF.s:466    .text:00000000000001b4 drivePentagonCCW
     /tmp/ccqLPhZF.s:480    .text:00000000000001b6 driveStraight
     /tmp/ccqLPhZF.s:552    .text:00000000000001fc rotate
     /tmp/ccqLPhZF.s:623    .text:0000000000000242 stopCreate
     /tmp/ccqLPhZF.s:656    .text:0000000000000260 drivePentagonCW
     /tmp/ccqLPhZF.s:719    .text:000000000000029c buttonDetect

UNDEFINED SYMBOLS
byteTx
delayMs
byteRx
