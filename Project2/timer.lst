   1               		.file	"timer.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_18
  12               	__vector_18:
  13               	.LFB0:
  14               		.file 1 "timer.c"
   1:timer.c       **** #include "timer.h"    // Declaration made available here
   2:timer.c       **** 
   3:timer.c       **** 
   4:timer.c       **** // Timer variables defined here
   5:timer.c       **** volatile uint16_t delayTimerCount = 0;            // Definition checked against declaration
   6:timer.c       **** volatile uint16_t ToggleCMDTimerCount = 0;            // Definition checked against declaration
   7:timer.c       **** 
   8:timer.c       **** volatile uint8_t  delayTimerRunning = 0;          // Definition checked against declaration
   9:timer.c       **** volatile uint8_t  ToggleCMDTimerRunning = 0;          // Definition checked against declaration
  10:timer.c       **** 
  11:timer.c       **** 
  12:timer.c       **** 
  13:timer.c       **** ISR(USART_RX_vect) {  //SIGNAL(SIG_USART_RECV) 
  15               		.loc 1 13 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28               	/* prologue: Signal */
  29               	/* frame size = 0 */
  30               	/* stack size = 3 */
  31               	.L__stack_usage = 3
  32               	/* epilogue start */
  14:timer.c       ****   // Serial receive interrupt to store sensor values
  15:timer.c       ****   
  16:timer.c       ****   // CSCE 274 students, I have only ever used this method 
  17:timer.c       ****   // when retrieving/storing a large amount of sensor data. 
  18:timer.c       ****   // You DO NOT need it for this assignment. If i feel it 
  19:timer.c       ****   // becomes relevant, I will show you how/when to use it.
  20:timer.c       **** }
  33               		.loc 1 20 0
  34 000a 0F90      		pop r0
  35 000c 0FBE      		out __SREG__,r0
  36 000e 0F90      		pop r0
  37 0010 1F90      		pop r1
  38 0012 1895      		reti
  39               		.cfi_endproc
  40               	.LFE0:
  42               	.global	__vector_11
  44               	__vector_11:
  45               	.LFB1:
  21:timer.c       **** 
  22:timer.c       **** //SIGNAL(SIG_OUTPUT_COMPARE1A)
  23:timer.c       **** ISR(TIMER1_COMPA_vect) {
  46               		.loc 1 23 0
  47               		.cfi_startproc
  48 0014 1F92      		push r1
  49               	.LCFI2:
  50               		.cfi_def_cfa_offset 3
  51               		.cfi_offset 1, -2
  52 0016 0F92      		push r0
  53               	.LCFI3:
  54               		.cfi_def_cfa_offset 4
  55               		.cfi_offset 0, -3
  56 0018 0FB6      		in r0,__SREG__
  57 001a 0F92      		push r0
  58 001c 1124      		clr __zero_reg__
  59 001e 8F93      		push r24
  60               	.LCFI4:
  61               		.cfi_def_cfa_offset 5
  62               		.cfi_offset 24, -4
  63 0020 9F93      		push r25
  64               	.LCFI5:
  65               		.cfi_def_cfa_offset 6
  66               		.cfi_offset 25, -5
  67               	/* prologue: Signal */
  68               	/* frame size = 0 */
  69               	/* stack size = 5 */
  70               	.L__stack_usage = 5
  24:timer.c       ****   // Interrupt handler called every 1ms.
  25:timer.c       ****   // Decrement the counter variable, to allow delayMs to keep time.
  26:timer.c       ****   if(delayTimerCount != 0) {
  71               		.loc 1 26 0
  72 0022 8091 0000 		lds r24,delayTimerCount
  73 0026 9091 0000 		lds r25,delayTimerCount+1
  74 002a 892B      		or r24,r25
  75 002c 01F0      		breq .L3
  27:timer.c       ****     delayTimerCount--;
  76               		.loc 1 27 0
  77 002e 8091 0000 		lds r24,delayTimerCount
  78 0032 9091 0000 		lds r25,delayTimerCount+1
  79 0036 0197      		sbiw r24,1
  80 0038 9093 0000 		sts delayTimerCount+1,r25
  81 003c 8093 0000 		sts delayTimerCount,r24
  82 0040 00C0      		rjmp .L4
  83               	.L3:
  28:timer.c       ****   } else {
  29:timer.c       ****     delayTimerRunning = 0;
  84               		.loc 1 29 0
  85 0042 1092 0000 		sts delayTimerRunning,__zero_reg__
  86               	.L4:
  30:timer.c       ****   }
  31:timer.c       ****    
  32:timer.c       ****   if(ToggleCMDTimerCount  != 0) {
  87               		.loc 1 32 0
  88 0046 8091 0000 		lds r24,ToggleCMDTimerCount
  89 004a 9091 0000 		lds r25,ToggleCMDTimerCount+1
  90 004e 892B      		or r24,r25
  91 0050 01F0      		breq .L2
  33:timer.c       ****     ToggleCMDTimerCount--;
  92               		.loc 1 33 0
  93 0052 8091 0000 		lds r24,ToggleCMDTimerCount
  94 0056 9091 0000 		lds r25,ToggleCMDTimerCount+1
  95 005a 0197      		sbiw r24,1
  96 005c 9093 0000 		sts ToggleCMDTimerCount+1,r25
  97 0060 8093 0000 		sts ToggleCMDTimerCount,r24
  98               	.L2:
  99               	/* epilogue start */
  34:timer.c       ****   }
  35:timer.c       **** 
  36:timer.c       **** }
 100               		.loc 1 36 0
 101 0064 9F91      		pop r25
 102 0066 8F91      		pop r24
 103 0068 0F90      		pop r0
 104 006a 0FBE      		out __SREG__,r0
 105 006c 0F90      		pop r0
 106 006e 1F90      		pop r1
 107 0070 1895      		reti
 108               		.cfi_endproc
 109               	.LFE1:
 111               	.global	setupTimer
 113               	setupTimer:
 114               	.LFB2:
  37:timer.c       **** 
  38:timer.c       **** void setupTimer(void) {
 115               		.loc 1 38 0
 116               		.cfi_startproc
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
  39:timer.c       **** // Set up the timer 1 interupt to be called every 1ms.
  40:timer.c       **** // It's probably best to treat this as a black box.
  41:timer.c       **** // Basic idea: Except for the 71, these are special codes, for which details
  42:timer.c       **** // appear in the ATMega168 data sheet. The 71 is a computed value, based on
  43:timer.c       **** // the processor speed and the amount of "scaling" of the timer, that gives
  44:timer.c       **** // us the 1ms time interval.
  45:timer.c       ****   TCCR1A = 0x00;
 121               		.loc 1 45 0
 122 0072 1092 8000 		sts 128,__zero_reg__
  46:timer.c       ****   TCCR1B = (_BV(WGM12) | _BV(CS12));
 123               		.loc 1 46 0
 124 0076 8CE0      		ldi r24,lo8(12)
 125 0078 8093 8100 		sts 129,r24
  47:timer.c       ****     // TCCR1B = 0x0C;
  48:timer.c       ****   OCR1A = 71;
 126               		.loc 1 48 0
 127 007c 87E4      		ldi r24,lo8(71)
 128 007e 90E0      		ldi r25,0
 129 0080 9093 8900 		sts 136+1,r25
 130 0084 8093 8800 		sts 136,r24
  49:timer.c       ****   TIMSK1 = _BV(OCIE1A);
 131               		.loc 1 49 0
 132 0088 82E0      		ldi r24,lo8(2)
 133 008a 8093 6F00 		sts 111,r24
 134 008e 0895      		ret
 135               		.cfi_endproc
 136               	.LFE2:
 138               	.global	delayMs
 140               	delayMs:
 141               	.LFB3:
  50:timer.c       ****     // TIMSK1 = 0x02;
  51:timer.c       **** }
  52:timer.c       **** 
  53:timer.c       **** // Delay for the specified time in ms without updating sensor values
  54:timer.c       **** void delayMs(uint16_t time_ms)
  55:timer.c       **** {
 142               		.loc 1 55 0
 143               		.cfi_startproc
 144               	.LVL0:
 145               	/* prologue: function */
 146               	/* frame size = 0 */
 147               	/* stack size = 0 */
 148               	.L__stack_usage = 0
  56:timer.c       ****   delayTimerRunning = 1;
 149               		.loc 1 56 0
 150 0090 21E0      		ldi r18,lo8(1)
 151 0092 2093 0000 		sts delayTimerRunning,r18
  57:timer.c       ****   delayTimerCount = time_ms;
 152               		.loc 1 57 0
 153 0096 9093 0000 		sts delayTimerCount+1,r25
 154 009a 8093 0000 		sts delayTimerCount,r24
 155               	.LVL1:
 156               	.L13:
  58:timer.c       ****   while(delayTimerRunning) ;
 157               		.loc 1 58 0 discriminator 1
 158 009e 8091 0000 		lds r24,delayTimerRunning
 159 00a2 8111      		cpse r24,__zero_reg__
 160 00a4 00C0      		rjmp .L13
 161               	/* epilogue start */
  59:timer.c       **** }
 162               		.loc 1 59 0
 163 00a6 0895      		ret
 164               		.cfi_endproc
 165               	.LFE3:
 167               	.global	ToggleCMDTimer
 169               	ToggleCMDTimer:
 170               	.LFB4:
  60:timer.c       **** void ToggleCMDTimer(uint16_t time_ms2)
  61:timer.c       **** {
 171               		.loc 1 61 0
 172               		.cfi_startproc
 173               	.LVL2:
 174               	/* prologue: function */
 175               	/* frame size = 0 */
 176               	/* stack size = 0 */
 177               	.L__stack_usage = 0
 178 00a8 0895      		ret
 179               		.cfi_endproc
 180               	.LFE4:
 182               	.global	ToggleCMDTimerRunning
 183               		.section .bss
 186               	ToggleCMDTimerRunning:
 187 0000 00        		.zero	1
 188               	.global	delayTimerRunning
 191               	delayTimerRunning:
 192 0001 00        		.zero	1
 193               	.global	ToggleCMDTimerCount
 196               	ToggleCMDTimerCount:
 197 0002 0000      		.zero	2
 198               	.global	delayTimerCount
 201               	delayTimerCount:
 202 0004 0000      		.zero	2
 203               		.text
 204               	.Letext0:
 205               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 timer.c
     /tmp/ccRUQN9s.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccRUQN9s.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccRUQN9s.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccRUQN9s.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccRUQN9s.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccRUQN9s.s:12     .text:0000000000000000 __vector_18
     /tmp/ccRUQN9s.s:44     .text:0000000000000014 __vector_11
     /tmp/ccRUQN9s.s:201    .bss:0000000000000004 delayTimerCount
     /tmp/ccRUQN9s.s:191    .bss:0000000000000001 delayTimerRunning
     /tmp/ccRUQN9s.s:196    .bss:0000000000000002 ToggleCMDTimerCount
     /tmp/ccRUQN9s.s:113    .text:0000000000000072 setupTimer
     /tmp/ccRUQN9s.s:140    .text:0000000000000090 delayMs
     /tmp/ccRUQN9s.s:169    .text:00000000000000a8 ToggleCMDTimer
     /tmp/ccRUQN9s.s:186    .bss:0000000000000000 ToggleCMDTimerRunning

UNDEFINED SYMBOLS
__do_clear_bss
