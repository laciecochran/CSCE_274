   1               		.file	"cmod.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	setSerialDestination
  12               	setSerialDestination:
  13               	.LFB2:
  14               		.file 1 "cmod.c"
   1:cmod.c        **** #include "cmod.h"
   2:cmod.c        **** #include "oi.h"
   3:cmod.c        **** #include "timer.h"
   4:cmod.c        **** 
   5:cmod.c        **** void initializeCommandModule(void){
   6:cmod.c        ****   // Disable interrupts. ("Clear interrupt bit")
   7:cmod.c        ****   cli();
   8:cmod.c        **** 
   9:cmod.c        ****   // One-time setup operations.
  10:cmod.c        ****   setupIOPins();
  11:cmod.c        ****   setupTimer();
  12:cmod.c        ****   setupSerialPort();
  13:cmod.c        **** 
  14:cmod.c        ****   // Enable interrupts. ("Set interrupt bit")
  15:cmod.c        ****   sei();
  16:cmod.c        **** }
  17:cmod.c        **** 
  18:cmod.c        **** void setSerialDestination(uint8_t dest) {
  15               		.loc 1 18 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22               	/* prologue: function */
  23               	/* frame size = 0 */
  24               	/* stack size = 1 */
  25               	.L__stack_usage = 1
  26 0002 C82F      		mov r28,r24
  19:cmod.c        ****   //delay so pending bytes are sent
  20:cmod.c        ****   delayMs(10);
  27               		.loc 1 20 0
  28 0004 8AE0      		ldi r24,lo8(10)
  29 0006 90E0      		ldi r25,0
  30               	.LVL1:
  31 0008 0E94 0000 		call delayMs
  32               	.LVL2:
  21:cmod.c        ****   //configure the port
  22:cmod.c        ****   if(dest == SERIAL_CREATE) {
  33               		.loc 1 22 0
  34 000c C130      		cpi r28,lo8(1)
  35 000e 01F4      		brne .L2
  23:cmod.c        ****     PORTB &= ~0x10;
  36               		.loc 1 23 0
  37 0010 2C98      		cbi 0x5,4
  38 0012 00C0      		rjmp .L3
  39               	.L2:
  24:cmod.c        ****   }
  25:cmod.c        ****   else {
  26:cmod.c        ****     PORTB |= 0x10;
  40               		.loc 1 26 0
  41 0014 2C9A      		sbi 0x5,4
  42               	.L3:
  27:cmod.c        ****   }
  28:cmod.c        **** 
  29:cmod.c        ****   delayMs(10);
  43               		.loc 1 29 0
  44 0016 8AE0      		ldi r24,lo8(10)
  45 0018 90E0      		ldi r25,0
  46               	/* epilogue start */
  30:cmod.c        **** }
  47               		.loc 1 30 0
  48 001a CF91      		pop r28
  49               	.LVL3:
  29:cmod.c        ****   delayMs(10);
  50               		.loc 1 29 0
  51 001c 0C94 0000 		jmp delayMs
  52               	.LVL4:
  53               		.cfi_endproc
  54               	.LFE2:
  56               	.global	setupIOPins
  58               	setupIOPins:
  59               	.LFB3:
  31:cmod.c        **** 
  32:cmod.c        **** void setupIOPins(void) {
  60               		.loc 1 32 0
  61               		.cfi_startproc
  62               	/* prologue: function */
  63               	/* frame size = 0 */
  64               	/* stack size = 0 */
  65               	.L__stack_usage = 0
  33:cmod.c        ****   // Set I/O pins
  34:cmod.c        ****   DDRB  = 0x10;
  66               		.loc 1 34 0
  67 0020 80E1      		ldi r24,lo8(16)
  68 0022 84B9      		out 0x4,r24
  35:cmod.c        ****   PORTB = 0xCF;
  69               		.loc 1 35 0
  70 0024 8FEC      		ldi r24,lo8(-49)
  71 0026 85B9      		out 0x5,r24
  36:cmod.c        ****   DDRC  = 0x00;
  72               		.loc 1 36 0
  73 0028 17B8      		out 0x7,__zero_reg__
  37:cmod.c        ****   PORTC = 0xFF;
  74               		.loc 1 37 0
  75 002a 8FEF      		ldi r24,lo8(-1)
  76 002c 88B9      		out 0x8,r24
  38:cmod.c        ****   DDRD  = 0xE6;
  77               		.loc 1 38 0
  78 002e 86EE      		ldi r24,lo8(-26)
  79 0030 8AB9      		out 0xa,r24
  39:cmod.c        ****   PORTD = 0x7D;
  80               		.loc 1 39 0
  81 0032 8DE7      		ldi r24,lo8(125)
  82 0034 8BB9      		out 0xb,r24
  83 0036 0895      		ret
  84               		.cfi_endproc
  85               	.LFE3:
  87               	.global	setupSerialPort
  89               	setupSerialPort:
  90               	.LFB4:
  40:cmod.c        **** }
  41:cmod.c        **** 
  42:cmod.c        **** void setupSerialPort(void) {
  91               		.loc 1 42 0
  92               		.cfi_startproc
  93               	/* prologue: function */
  94               	/* frame size = 0 */
  95               	/* stack size = 0 */
  96               	.L__stack_usage = 0
  43:cmod.c        ****   // Set the transmission speed to 57600 baud, which is what the Create expects,
  44:cmod.c        ****   // unless we tell it otherwise.
  45:cmod.c        ****   UBRR0 = 19;
  97               		.loc 1 45 0
  98 0038 83E1      		ldi r24,lo8(19)
  99 003a 90E0      		ldi r25,0
 100 003c 9093 C500 		sts 196+1,r25
 101 0040 8093 C400 		sts 196,r24
  46:cmod.c        ****   
  47:cmod.c        ****   // Enable both transmit and receive.
  48:cmod.c        ****   UCSR0B = (_BV(RXCIE0) | _BV(TXEN0) | _BV(RXEN0));
 102               		.loc 1 48 0
 103 0044 88E9      		ldi r24,lo8(-104)
 104 0046 8093 C100 		sts 193,r24
  49:cmod.c        ****     // UCSR0B = 0x18;
  50:cmod.c        ****   
  51:cmod.c        ****   // Set 8-bit data.
  52:cmod.c        ****   UCSR0C = (_BV(UCSZ00) | _BV(UCSZ01));
 105               		.loc 1 52 0
 106 004a 86E0      		ldi r24,lo8(6)
 107 004c 8093 C200 		sts 194,r24
 108 0050 0895      		ret
 109               		.cfi_endproc
 110               	.LFE4:
 112               	.global	initializeCommandModule
 114               	initializeCommandModule:
 115               	.LFB1:
   5:cmod.c        **** void initializeCommandModule(void){
 116               		.loc 1 5 0
 117               		.cfi_startproc
 118               	/* prologue: function */
 119               	/* frame size = 0 */
 120               	/* stack size = 0 */
 121               	.L__stack_usage = 0
   7:cmod.c        ****   cli();
 122               		.loc 1 7 0
 123               	/* #APP */
 124               	 ;  7 "cmod.c" 1
 125 0052 F894      		cli
 126               	 ;  0 "" 2
  10:cmod.c        ****   setupIOPins();
 127               		.loc 1 10 0
 128               	/* #NOAPP */
 129 0054 0E94 0000 		call setupIOPins
 130               	.LVL5:
  11:cmod.c        ****   setupTimer();
 131               		.loc 1 11 0
 132 0058 0E94 0000 		call setupTimer
 133               	.LVL6:
  12:cmod.c        ****   setupSerialPort();
 134               		.loc 1 12 0
 135 005c 0E94 0000 		call setupSerialPort
 136               	.LVL7:
  15:cmod.c        ****   sei();
 137               		.loc 1 15 0
 138               	/* #APP */
 139               	 ;  15 "cmod.c" 1
 140 0060 7894      		sei
 141               	 ;  0 "" 2
 142               	/* #NOAPP */
 143 0062 0895      		ret
 144               		.cfi_endproc
 145               	.LFE1:
 147               	.global	byteTx
 149               	byteTx:
 150               	.LFB5:
  53:cmod.c        ****     // UCSR0C = 0x06;
  54:cmod.c        **** }
  55:cmod.c        **** 
  56:cmod.c        **** void byteTx(uint8_t value) {
 151               		.loc 1 56 0
 152               		.cfi_startproc
 153               	/* prologue: function */
 154               	/* frame size = 0 */
 155               	/* stack size = 0 */
 156               	.L__stack_usage = 0
 157               	.LVL8:
 158               	.L10:
  57:cmod.c        ****   // Transmit one byte to the robot.
  58:cmod.c        ****   // Wait for the buffer to be empty.
  59:cmod.c        ****   while(!(UCSR0A & 0x20)) ;
 159               		.loc 1 59 0 discriminator 1
 160 0064 9091 C000 		lds r25,192
 161 0068 95FF      		sbrs r25,5
 162 006a 00C0      		rjmp .L10
  60:cmod.c        **** 
  61:cmod.c        ****   // Send the byte.
  62:cmod.c        ****   UDR0 = value;
 163               		.loc 1 62 0
 164 006c 8093 C600 		sts 198,r24
 165 0070 0895      		ret
 166               		.cfi_endproc
 167               	.LFE5:
 169               	.global	byteRx
 171               	byteRx:
 172               	.LFB6:
  63:cmod.c        **** }
  64:cmod.c        **** 
  65:cmod.c        **** uint8_t byteRx(void) {
 173               		.loc 1 65 0
 174               		.cfi_startproc
 175               	/* prologue: function */
 176               	/* frame size = 0 */
 177               	/* stack size = 0 */
 178               	.L__stack_usage = 0
 179               	.L13:
  66:cmod.c        ****   // Receive one byte from the robot.
  67:cmod.c        ****   // Call setupSerialPort() first.
  68:cmod.c        ****   // Wait for a byte to arrive in the recieve buffer.
  69:cmod.c        ****   while(!(UCSR0A & 0x80)) ;
 180               		.loc 1 69 0 discriminator 1
 181 0072 8091 C000 		lds r24,192
 182 0076 87FF      		sbrs r24,7
 183 0078 00C0      		rjmp .L13
  70:cmod.c        ****   
  71:cmod.c        ****   // Return that byte.
  72:cmod.c        ****   return UDR0;
 184               		.loc 1 72 0
 185 007a 8091 C600 		lds r24,198
  73:cmod.c        **** }
 186               		.loc 1 73 0
 187 007e 0895      		ret
 188               		.cfi_endproc
 189               	.LFE6:
 191               	.global	baud
 193               	baud:
 194               	.LFB7:
  74:cmod.c        **** 
  75:cmod.c        **** void baud(uint8_t baud_code) {
 195               		.loc 1 75 0
 196               		.cfi_startproc
 197               	.LVL9:
 198 0080 CF93      		push r28
 199               	.LCFI1:
 200               		.cfi_def_cfa_offset 3
 201               		.cfi_offset 28, -2
 202               	/* prologue: function */
 203               	/* frame size = 0 */
 204               	/* stack size = 1 */
 205               	.L__stack_usage = 1
 206 0082 C82F      		mov r28,r24
  76:cmod.c        ****   // Switch the baud rate on both Create and module
  77:cmod.c        ****   if(baud_code <= 11)
 207               		.loc 1 77 0
 208 0084 8C30      		cpi r24,lo8(12)
 209 0086 00F0      		brlo .+2
 210 0088 00C0      		rjmp .L14
  78:cmod.c        ****   {
  79:cmod.c        ****     byteTx(CmdBaud);
 211               		.loc 1 79 0
 212 008a 81E8      		ldi r24,lo8(-127)
 213               	.LVL10:
 214 008c 0E94 0000 		call byteTx
 215               	.LVL11:
  80:cmod.c        ****     UCSR0A |= _BV(TXC0);
 216               		.loc 1 80 0
 217 0090 8091 C000 		lds r24,192
 218 0094 8064      		ori r24,lo8(64)
 219 0096 8093 C000 		sts 192,r24
  81:cmod.c        ****     byteTx(baud_code);
 220               		.loc 1 81 0
 221 009a 8C2F      		mov r24,r28
 222 009c 0E94 0000 		call byteTx
 223               	.LVL12:
 224               	.L17:
  82:cmod.c        ****     // Wait until transmit is complete
  83:cmod.c        ****     while(!(UCSR0A & _BV(TXC0))) ;
 225               		.loc 1 83 0 discriminator 1
 226 00a0 8091 C000 		lds r24,192
 227 00a4 86FF      		sbrs r24,6
 228 00a6 00C0      		rjmp .L17
  84:cmod.c        **** 
  85:cmod.c        ****     cli();
 229               		.loc 1 85 0
 230               	/* #APP */
 231               	 ;  85 "cmod.c" 1
 232 00a8 F894      		cli
 233               	 ;  0 "" 2
  86:cmod.c        **** 
  87:cmod.c        ****     // Switch the baud rate register
  88:cmod.c        ****     if(baud_code == Baud115200) {
 234               		.loc 1 88 0
 235               	/* #NOAPP */
 236 00aa CB30      		cpi r28,lo8(11)
 237 00ac 01F4      		brne .L18
  89:cmod.c        ****       UBRR0 = Ubrr115200;
 238               		.loc 1 89 0
 239 00ae 89E0      		ldi r24,lo8(9)
 240 00b0 90E0      		ldi r25,0
 241 00b2 00C0      		rjmp .L30
 242               	.L18:
  90:cmod.c        ****     } else if(baud_code == Baud57600) {
 243               		.loc 1 90 0
 244 00b4 CA30      		cpi r28,lo8(10)
 245 00b6 01F4      		brne .L20
  91:cmod.c        ****       UBRR0 = Ubrr57600;
 246               		.loc 1 91 0
 247 00b8 83E1      		ldi r24,lo8(19)
 248 00ba 90E0      		ldi r25,0
 249 00bc 00C0      		rjmp .L30
 250               	.L20:
  92:cmod.c        ****     } else if(baud_code == Baud38400) {
 251               		.loc 1 92 0
 252 00be C930      		cpi r28,lo8(9)
 253 00c0 01F4      		brne .L21
  93:cmod.c        ****       UBRR0 = Ubrr38400;
 254               		.loc 1 93 0
 255 00c2 8DE1      		ldi r24,lo8(29)
 256 00c4 90E0      		ldi r25,0
 257 00c6 00C0      		rjmp .L30
 258               	.L21:
  94:cmod.c        ****     } else if(baud_code == Baud28800) {
 259               		.loc 1 94 0
 260 00c8 C830      		cpi r28,lo8(8)
 261 00ca 01F4      		brne .L22
  95:cmod.c        ****       UBRR0 = Ubrr28800;
 262               		.loc 1 95 0
 263 00cc 87E2      		ldi r24,lo8(39)
 264 00ce 90E0      		ldi r25,0
 265 00d0 00C0      		rjmp .L30
 266               	.L22:
  96:cmod.c        ****     } else if(baud_code == Baud19200) {
 267               		.loc 1 96 0
 268 00d2 C730      		cpi r28,lo8(7)
 269 00d4 01F4      		brne .L23
  97:cmod.c        ****       UBRR0 = Ubrr19200;
 270               		.loc 1 97 0
 271 00d6 8BE3      		ldi r24,lo8(59)
 272 00d8 90E0      		ldi r25,0
 273 00da 00C0      		rjmp .L30
 274               	.L23:
  98:cmod.c        ****     } else if(baud_code == Baud14400) {
 275               		.loc 1 98 0
 276 00dc C630      		cpi r28,lo8(6)
 277 00de 01F4      		brne .L24
  99:cmod.c        ****       UBRR0 = Ubrr14400;
 278               		.loc 1 99 0
 279 00e0 8FE4      		ldi r24,lo8(79)
 280 00e2 90E0      		ldi r25,0
 281 00e4 00C0      		rjmp .L30
 282               	.L24:
 100:cmod.c        ****     } else if(baud_code == Baud9600) {
 283               		.loc 1 100 0
 284 00e6 C530      		cpi r28,lo8(5)
 285 00e8 01F4      		brne .L25
 101:cmod.c        ****       UBRR0 = Ubrr9600;
 286               		.loc 1 101 0
 287 00ea 87E7      		ldi r24,lo8(119)
 288 00ec 90E0      		ldi r25,0
 289 00ee 00C0      		rjmp .L30
 290               	.L25:
 102:cmod.c        ****     } else if(baud_code == Baud4800) {
 291               		.loc 1 102 0
 292 00f0 C430      		cpi r28,lo8(4)
 293 00f2 01F4      		brne .L26
 103:cmod.c        ****       UBRR0 = Ubrr4800;
 294               		.loc 1 103 0
 295 00f4 8FEE      		ldi r24,lo8(-17)
 296 00f6 90E0      		ldi r25,0
 297 00f8 00C0      		rjmp .L30
 298               	.L26:
 104:cmod.c        ****     } else if(baud_code == Baud2400) {
 299               		.loc 1 104 0
 300 00fa C330      		cpi r28,lo8(3)
 301 00fc 01F4      		brne .L27
 105:cmod.c        ****       UBRR0 = Ubrr2400;
 302               		.loc 1 105 0
 303 00fe 8FED      		ldi r24,lo8(-33)
 304 0100 91E0      		ldi r25,lo8(1)
 305 0102 00C0      		rjmp .L30
 306               	.L27:
 106:cmod.c        ****     } else if(baud_code == Baud1200) {
 307               		.loc 1 106 0
 308 0104 C230      		cpi r28,lo8(2)
 309 0106 01F4      		brne .L28
 107:cmod.c        ****       UBRR0 = Ubrr1200;
 310               		.loc 1 107 0
 311 0108 8FEB      		ldi r24,lo8(-65)
 312 010a 93E0      		ldi r25,lo8(3)
 313 010c 00C0      		rjmp .L30
 314               	.L28:
 108:cmod.c        ****     } else if(baud_code == Baud600) {
 315               		.loc 1 108 0
 316 010e C130      		cpi r28,lo8(1)
 317 0110 01F4      		brne .L29
 109:cmod.c        ****       UBRR0 = Ubrr600;
 318               		.loc 1 109 0
 319 0112 8FE7      		ldi r24,lo8(127)
 320 0114 97E0      		ldi r25,lo8(7)
 321 0116 00C0      		rjmp .L30
 322               	.L29:
 110:cmod.c        ****     } else if(baud_code == Baud300) {
 111:cmod.c        ****       UBRR0 = Ubrr300;
 323               		.loc 1 111 0
 324 0118 8FEF      		ldi r24,lo8(-1)
 325 011a 9EE0      		ldi r25,lo8(14)
 326               	.L30:
 327 011c 9093 C500 		sts 196+1,r25
 328 0120 8093 C400 		sts 196,r24
 112:cmod.c        ****     }
 113:cmod.c        ****     sei();
 329               		.loc 1 113 0
 330               	/* #APP */
 331               	 ;  113 "cmod.c" 1
 332 0124 7894      		sei
 333               	 ;  0 "" 2
 114:cmod.c        **** 
 115:cmod.c        ****     delayMs(100);
 334               		.loc 1 115 0
 335               	/* #NOAPP */
 336 0126 84E6      		ldi r24,lo8(100)
 337 0128 90E0      		ldi r25,0
 338               	/* epilogue start */
 116:cmod.c        ****   }
 117:cmod.c        **** }
 339               		.loc 1 117 0
 340 012a CF91      		pop r28
 341               	.LVL13:
 115:cmod.c        ****     delayMs(100);
 342               		.loc 1 115 0
 343 012c 0C94 0000 		jmp delayMs
 344               	.LVL14:
 345               	.L14:
 346               	/* epilogue start */
 347               		.loc 1 117 0
 348 0130 CF91      		pop r28
 349 0132 0895      		ret
 350               		.cfi_endproc
 351               	.LFE7:
 353               		.comm	timer2Scale,1,1
 354               	.Letext0:
 355               		.file 2 "/usr/lib/avr/include/stdint.h"
 356               		.file 3 "timer.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 cmod.c
     /tmp/cceYn183.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cceYn183.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cceYn183.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cceYn183.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cceYn183.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cceYn183.s:12     .text:0000000000000000 setSerialDestination
     /tmp/cceYn183.s:58     .text:0000000000000020 setupIOPins
     /tmp/cceYn183.s:89     .text:0000000000000038 setupSerialPort
     /tmp/cceYn183.s:114    .text:0000000000000052 initializeCommandModule
     /tmp/cceYn183.s:149    .text:0000000000000064 byteTx
     /tmp/cceYn183.s:171    .text:0000000000000072 byteRx
     /tmp/cceYn183.s:193    .text:0000000000000080 baud
                            *COM*:0000000000000001 timer2Scale

UNDEFINED SYMBOLS
delayMs
setupTimer
__do_clear_bss
